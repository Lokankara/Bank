<h2>64.6. Hash Indexes #</h2>
<p>PostgreSQL включает реализацию постоянных хэш-индексов на диске, которые полностью восстанавливаются после сбоя. Любой тип данных может быть проиндексирован хэш-индексом, включая типы данных, которые не имеют четко определенного линейного порядка. Хэш-индексы хранят только хэш-значение индексируемых данных, поэтому нет ограничений на размер индексируемого столбца данных.</p><p>Хэш-индексы поддерживают только одностолбцовые индексы и не позволяют проверять уникальность.</p><p>Хэш-индексы поддерживают только оператор =, поэтому предложения WHERE, определяющие операции с диапазонами, не смогут воспользоваться преимуществами хэш-индексов.</p><p>Каждый кортеж индекса хэша хранит только 4-байтовое значение хэша, а не фактическое значение столбца. В результате индексы хэша могут быть намного меньше B-деревьев при индексировании более длинных элементов данных, таких как UUID, URL и т. д. Отсутствие значения столбца также делает все сканирования индекса хэша потерями. Индексы хэша могут принимать участие в сканированиях индекса битовой карты и обратном сканировании.</p><p>Хэш-индексы лучше всего оптимизированы для рабочих нагрузок с большими объемами SELECT и UPDATE, которые используют сканирование равенства в больших таблицах. В индексе B-дерева поиск должен спускаться по дереву, пока не будет найдена конечная страница. В таблицах с миллионами строк этот спуск может увеличить время доступа к данным. Эквивалент конечной страницы в хэш-индексе называется страницей контейнера. Напротив, хэш-индекс позволяет получать доступ к страницам контейнера напрямую, тем самым потенциально сокращая время доступа к индексу в больших таблицах. Это сокращение «логического ввода-вывода» становится еще более выраженным для индексов/данных, больших, чем shared_buffers/RAM.</p><p>Индексы хэша были разработаны для того, чтобы справляться с неравномерным распределением значений хэша. Прямой доступ к страницам контейнера работает хорошо, если значения хэша распределены равномерно. Когда вставки приводят к заполнению страницы контейнера, дополнительные страницы переполнения привязываются к этой конкретной странице контейнера, локально расширяя хранилище для кортежей индекса, которые соответствуют этому значению хэша. При сканировании контейнера хэша во время запросов нам необходимо сканировать все страницы переполнения. Таким образом, несбалансированный индекс хэша может быть на самом деле хуже, чем B-дерево с точки зрения количества требуемых доступов к блокам для некоторых данных.</p><p>В результате случаев переполнения мы можем сказать, что хэш-индексы наиболее подходят для уникальных, почти уникальных данных или данных с небольшим количеством строк на хэш-контейнер. Один из возможных способов избежать проблем — исключить из индекса крайне неуникальные значения с помощью частичного индексного условия, но во многих случаях это может не подойти.</p><p>Как и B-деревья, хэш-индексы выполняют простое удаление кортежей индексов. Это отложенная операция обслуживания, которая удаляет кортежи индексов, которые, как известно, можно безопасно удалить (те, у которых бит идентификатора элемента LP_DEAD уже установлен). Если вставка обнаруживает, что на странице нет свободного места, мы пытаемся избежать создания новой страницы переполнения, пытаясь удалить мертвые кортежи индексов. Удаление не может произойти, если страница в это время закреплена. Удаление мертвых указателей индексов также происходит во время VACUUM.</p><p>Если это возможно, VACUUM также попытается втиснуть индексные кортежи на как можно меньшее количество страниц переполнения, минимизируя цепочку переполнения. Если страница переполнения становится пустой, страницы переполнения могут быть повторно использованы в других бакетах, хотя мы никогда не возвращаем их в операционную систему. В настоящее время нет возможности сжать хэш-индекс, кроме как перестроить его с помощью REINDEX. Также нет возможности уменьшить количество бакетов.</p><p>Индексы хэша могут расширять количество страниц контейнеров по мере роста количества индексированных строк. Сопоставление ключа хэша с номером контейнера выбирается таким образом, чтобы индекс мог постепенно расширяться. Когда в индекс добавляется новый контейнер, необходимо будет «разделить» ровно один существующий контейнер, при этом некоторые его кортежи будут перенесены в новый контейнер в соответствии с обновленным сопоставлением ключа с номером контейнера.</p><p>Расширение происходит на переднем плане, что может увеличить время выполнения пользовательских вставок. Таким образом, хэш-индексы могут не подходить для таблиц с быстро растущим числом строк.</p><p>В хэш-индексе есть четыре типа страниц: метастраница (нулевая страница), которая содержит статически выделенную управляющую информацию; основные страницы корзины; страницы переполнения; и страницы битовой карты, которые отслеживают страницы переполнения, которые были освобождены и доступны для повторного использования. Для целей адресации страницы битовой карты рассматриваются как подмножество страниц переполнения.</p><p>Как сканирование индекса, так и вставка кортежей требуют нахождения контейнера, в котором должен находиться данный кортеж. Для этого нам нужны количество контейнеров, верхняя маска и нижняя маска из метастраницы; однако, по соображениям производительности нежелательно блокировать и закреплять метастраницу для каждой такой операции. Вместо этого мы сохраняем кэшированную копию метастраницы в записи relcache каждого бэкэнда. Это даст правильное сопоставление контейнера, пока целевой контейнер не был разделен с момента последнего обновления кэша.</p><p>Первичные страницы контейнера и страницы переполнения выделяются независимо, поскольку любому заданному индексу может потребоваться больше или меньше страниц переполнения относительно его количества контейнеров. Хэш-код использует интересный набор правил адресации для поддержки переменного количества страниц переполнения, при этом не требуется перемещать первичные страницы контейнера после их создания.</p><p>Каждая строка в индексированной таблице представлена ​​одним кортежем индекса в хэш-индексе. Кортежи хэш-индекса хранятся на страницах сегмента, и если они существуют, переполняют страницы. Мы ускоряем поиск, сохраняя записи индекса на любой странице индекса отсортированными по хэш-коду, что позволяет использовать бинарный поиск на странице индекса. Однако следует отметить, что нет *никаких* предположений об относительном порядке хэш-кодов на разных страницах индекса сегмента.</p><p>Алгоритмы разделения корзины для расширения хэш-индекса слишком сложны, чтобы упоминать их здесь, хотя они более подробно описаны в src/backend/access/hash/README. Алгоритм разделения защищен от сбоев и может быть перезапущен, если не будет успешно завершен.</p>