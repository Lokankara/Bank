<h2>11.1. Introduction #</h2>
<p>Предположим, у нас есть таблица, подобная этой:</p><pre>
CREATE TABLE test1 (
    id integer,
    content varchar
);
</pre>

<p>и приложение выдает множество запросов вида:</p><pre>
SELECT content FROM test1 WHERE id = constant;
</pre>

<p>Без предварительной подготовки системе пришлось бы сканировать всю таблицу test1, строку за строкой, чтобы найти все соответствующие записи. Если в test1 много строк и только несколько строк (возможно, ноль или одна) будут возвращены таким запросом, это явно неэффективный метод. Но если системе было поручено поддерживать индекс в столбце id, она может использовать более эффективный метод для поиска соответствующих строк. Например, ей может потребоваться пройти всего несколько уровней вглубь дерева поиска.</p><p>Похожий подход используется в большинстве научно-популярных книг: термины и концепции, которые часто ищут читатели, собраны в алфавитном указателе в конце книги. Заинтересованный читатель может сравнительно быстро просмотреть указатель и перейти на нужную страницу(ы), вместо того, чтобы читать всю книгу, чтобы найти интересующий материал. Так же, как задача автора — предвидеть, какие элементы читатели, скорее всего, будут искать, задача программиста базы данных — предвидеть, какие индексы будут полезны.</p><p>Для создания индекса по столбцу id можно использовать следующую команду, как обсуждалось ранее:</p><pre>
CREATE INDEX test1_id_index ON test1 (id);
</pre>

<p>Имя test1_id_index можно выбрать произвольно, но следует выбрать что-то такое, что позволит вам позже вспомнить, для чего предназначался индекс.</p><p>Чтобы удалить индекс, используйте команду DROP INDEX. Индексы можно добавлять и удалять из таблиц в любое время.</p><p>После создания индекса дальнейшее вмешательство не требуется: система обновит индекс при изменении таблицы и будет использовать индекс в запросах, когда посчитает, что это будет эффективнее последовательного сканирования таблицы. Но вам, возможно, придется регулярно запускать команду ANALYZE для обновления статистики, чтобы планировщик запросов мог принимать обоснованные решения. См. Главу 14 для получения информации о том, как узнать, используется ли индекс, а также когда и почему планировщик может решить не использовать индекс.</p><p>Индексы также могут принести пользу командам UPDATE и DELETE с условиями поиска. Кроме того, индексы могут использоваться в поиске с объединением. Таким образом, индекс, определенный для столбца, который является частью условия объединения, может также значительно ускорить запросы с объединениями.</p><p>В общем случае индексы PostgreSQL можно использовать для оптимизации запросов, содержащих одно или несколько предложений WHERE или JOIN в форме</p><pre>
indexed-column indexable-operator comparison-value
</pre>

<p>Здесь индексированный-столбец — это любой столбец или выражение, по которому был определен индекс. Индексируемый-оператор — это оператор, который является членом класса операторов индекса для индексированного столбца. (Более подробная информация об этом приведена ниже.) А значение сравнения может быть любым выражением, которое не является изменчивым и не ссылается на таблицу индекса.</p><p>В некоторых случаях планировщик запросов может извлечь индексируемое предложение этой формы из другой конструкции SQL. Простым примером является то, что если исходное предложение было</p><pre>
comparison-value operator indexed-column
</pre>

<p>затем его можно перевести в индексируемую форму, если исходный оператор имеет оператор-коммутатор, который является членом класса операторов индекса.</p><p>Создание индекса для большой таблицы может занять много времени. По умолчанию PostgreSQL позволяет выполнять чтение (операторы SELECT) для таблицы параллельно с созданием индекса, но записи (INSERT, UPDATE, DELETE) блокируются до завершения построения индекса. В производственных средах это часто неприемлемо. Можно разрешить выполнять запись параллельно с созданием индекса, но есть несколько предостережений, о которых следует знать — для получения дополнительной информации см. раздел Создание индексов одновременно.</p><p>После создания индекса система должна поддерживать его синхронизацию с таблицей. Это добавляет накладные расходы к операциям по манипулированию данными. Индексы также могут препятствовать созданию кортежей только для кучи. Поэтому индексы, которые редко или никогда не используются в запросах, следует удалить.</p>

<h2>11.2. Index Types #</h2>
<p>PostgreSQL предоставляет несколько типов индексов: B-tree, Hash, GiST, SP-GiST, GIN, BRIN и расширение bloom. Каждый тип индекса использует свой алгоритм, который лучше всего подходит для разных типов индексируемых предложений. По умолчанию команда CREATE INDEX создает индексы B-tree, которые подходят для наиболее распространенных ситуаций. Другие типы индексов выбираются путем написания ключевого слова USING, за которым следует имя типа индекса. Например, чтобы создать индекс Hash:</p><pre>
CREATE INDEX name ON table USING HASH (column);
</pre>

<p>B-деревья могут обрабатывать запросы на равенство и диапазон для данных, которые могут быть отсортированы в некотором порядке. В частности, планировщик запросов PostgreSQL будет рассматривать возможность использования индекса B-дерева всякий раз, когда индексированный столбец участвует в сравнении с использованием одного из этих операторов:</p><pre>
<   <=   =   >=   >
</pre>

<p>Конструкции, эквивалентные комбинациям этих операторов, например BETWEEN и IN, также могут быть реализованы с помощью поиска индекса B-дерева. Кроме того, условие IS NULL или IS NOT NULL в столбце индекса может быть использовано с индексом B-дерева.</p><p>Оптимизатор также может использовать индекс B-дерева для запросов, включающих операторы сопоставления с образцом LIKE и ~, если образец является константой и привязан к началу строки — например, col LIKE 'foo%' или col ~ '^foo', но не col LIKE '%bar'. Однако, если ваша база данных не использует локаль C, вам потребуется создать индекс со специальным классом операторов для поддержки индексации запросов сопоставления с образцом; см. Раздел 11.10 ниже. Также возможно использовать индексы B-дерева для ILIKE и ~*, но только если образец начинается с неалфавитных символов, т. е. символов, на которые не влияет преобразование верхнего/нижнего регистра.</p><p>Индексы B-tree также могут использоваться для извлечения данных в отсортированном порядке. Это не всегда быстрее, чем простое сканирование и сортировка, но часто полезно.</p><p>Индексы хэша хранят 32-битный хэш-код, полученный из значения индексированного столбца. Следовательно, такие индексы могут обрабатывать только простые сравнения на равенство. Планировщик запросов будет рассматривать возможность использования индекса хэша всякий раз, когда индексированный столбец участвует в сравнении с использованием оператора равенства:</p><pre>
=
</pre>

<p>Индексы GiST не являются единым типом индекса, а скорее инфраструктурой, в рамках которой могут быть реализованы многие различные стратегии индексирования. Соответственно, конкретные операторы, с которыми может использоваться индекс GiST, различаются в зависимости от стратегии индексирования (класса операторов). Например, стандартный дистрибутив PostgreSQL включает классы операторов GiST для нескольких двумерных геометрических типов данных, которые поддерживают индексированные запросы с использованием следующих операторов:</p><pre>
<<   &<   &>   >>   <<|   &<|   |&>   |>>   @>   <@   ~=   &&
</pre>

<p>(См. раздел 9.11 для выяснения значения этих операторов.) Классы операторов GiST, включенные в стандартный дистрибутив, задокументированы в таблице 64.1. Многие другие классы операторов GiST доступны в коллекции contrib или в виде отдельных проектов. Для получения дополнительной информации см. раздел 64.2.</p><p>Индексы GiST также способны оптимизировать поиск «ближайших соседей», например</p><pre>
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;

</pre>

<p>который находит десять мест, ближайших к заданной целевой точке. Возможность сделать это снова зависит от конкретного используемого класса операторов. В таблице 64.1 операторы, которые можно использовать таким образом, перечислены в столбце «Операторы упорядочивания».</p><p>Индексы SP-GiST, как и индексы GiST, предлагают инфраструктуру, которая поддерживает различные виды поиска. SP-GiST позволяет реализовать широкий спектр различных несбалансированных дисковых структур данных, таких как квадродеревья, деревья k-d и радиксные деревья (tries). Например, стандартный дистрибутив PostgreSQL включает классы операторов SP-GiST для двумерных точек, которые поддерживают индексированные запросы с использованием следующих операторов:</p><pre>
<<   >>   ~=   <@   <<|   |>>
</pre>

<p>(См. раздел 9.11 для выяснения значения этих операторов.) Классы операторов SP-GiST, включенные в стандартный дистрибутив, задокументированы в таблице 64.2. Для получения дополнительной информации см. раздел 64.3.</p><p>Как и GiST, SP-GiST поддерживает поиск «ближайшего соседа». Для классов операторов SP-GiST, которые поддерживают упорядочение по расстоянию, соответствующий оператор указан в столбце «Операторы упорядочивания» в таблице 64.2.</p><p>Индексы GIN — это «инвертированные индексы», которые подходят для значений данных, содержащих несколько значений компонентов, таких как массивы. Инвертированный индекс содержит отдельную запись для каждого значения компонента и может эффективно обрабатывать запросы, проверяющие наличие определенных значений компонентов.</p><p>Подобно GiST и SP-GiST, GIN может поддерживать множество различных определяемых пользователем стратегий индексирования, а конкретные операторы, с которыми может использоваться индекс GIN, различаются в зависимости от стратегии индексирования. Например, стандартный дистрибутив PostgreSQL включает класс операторов GIN для массивов, который поддерживает индексированные запросы с использованием следующих операторов:</p><pre>
<@   @>   =   &&
</pre>

<p>(См. раздел 9.19 для выяснения значения этих операторов.) Классы операторов GIN, включенные в стандартный дистрибутив, документированы в таблице 64.3. Многие другие классы операторов GIN доступны в коллекции contrib или в виде отдельных проектов. Для получения дополнительной информации см. раздел 64.4.</p><p>Индексы BRIN (сокращение от Block Range INdexes) хранят сводки о значениях, хранящихся в последовательных физических диапазонах блоков таблицы. Таким образом, они наиболее эффективны для столбцов, значения которых хорошо коррелируют с физическим порядком строк таблицы. Подобно GiST, SP-GiST и GIN, BRIN может поддерживать множество различных стратегий индексирования, а конкретные операторы, с которыми может использоваться индекс BRIN, различаются в зависимости от стратегии индексирования. Для типов данных с линейным порядком сортировки индексированные данные соответствуют минимальным и максимальным значениям значений в столбце для каждого диапазона блоков. Это поддерживает индексированные запросы с использованием следующих операторов:</p><pre>
<   <=   =   >=   >
</pre>

<p>Классы операторов BRIN, включенные в стандартный дистрибутив, документированы в Таблице 64.4. Для получения дополнительной информации см. Раздел 64.5.</p>

<h2>11.3. Multicolumn Indexes #</h2>
<p>Индекс может быть определен для более чем одного столбца таблицы. Например, если у вас есть таблица такой формы:</p><pre>
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
</pre>

<p>(скажем, вы храните каталог /dev в базе данных...) и часто выполняете запросы вроде:</p><pre>
SELECT name FROM test2 WHERE major = constant AND minor = constant;
</pre>

<p>тогда может быть целесообразно определить индекс по столбцам major и minor вместе, например:</p><pre>
CREATE INDEX test2_mm_idx ON test2 (major, minor);
</pre>

<p>В настоящее время только индексы B-tree, GiST, GIN и BRIN поддерживают индексы с несколькими ключевыми столбцами. Возможность использования нескольких ключевых столбцов не зависит от того, можно ли добавлять столбцы INCLUDE в индекс. Индексы могут иметь до 32 столбцов, включая столбцы INCLUDE. (Это ограничение можно изменить при построении PostgreSQL; см. файл pg_config_manual.h.)</p><p>Многостолбцовый индекс B-дерева может использоваться с условиями запроса, которые включают любое подмножество столбцов индекса, но индекс наиболее эффективен, когда есть ограничения на ведущие (самые левые) столбцы. Точное правило заключается в том, что ограничения равенства на ведущие столбцы, а также любые ограничения неравенства на первый столбец, который не имеет ограничения равенства, будут использоваться для ограничения части индекса, которая сканируется. Ограничения на столбцы справа от этих столбцов проверяются в индексе, поэтому они экономят посещения самой таблицы, но они не уменьшают часть индекса, которая должна быть просканирована. Например, если задан индекс на (a, b, c) и условие запроса WHERE a = 5 AND b >= 42 AND c < 77, индекс должен быть просканирован от первой записи с a = 5 и b = 42 до последней записи с a = 5. Записи индекса с c >= 77 будут пропущены, но их все равно придется просканировать. Этот индекс в принципе можно использовать для запросов, имеющих ограничения по b и/или c без ограничений по a, но для этого придется сканировать весь индекс, поэтому в большинстве случаев планировщик предпочтет последовательное сканирование таблицы использованию индекса.</p><p>Многостолбцовый индекс GiST может использоваться с условиями запроса, которые включают любое подмножество столбцов индекса. Условия для дополнительных столбцов ограничивают записи, возвращаемые индексом, но условие для первого столбца является наиболее важным для определения того, какая часть индекса должна быть просканирована. Индекс GiST будет относительно неэффективным, если его первый столбец имеет только несколько различных значений, даже если в дополнительных столбцах есть много различных значений.</p><p>Многостолбцовый индекс GIN может использоваться с условиями запроса, которые включают любое подмножество столбцов индекса. В отличие от B-дерева или GiST, эффективность поиска по индексу одинакова независимо от того, какой столбец(ы) индекса используются условиями запроса.</p><p>Многостолбцовый индекс BRIN может использоваться с условиями запроса, которые включают любое подмножество столбцов индекса. Как и GIN и в отличие от B-дерева или GiST, эффективность поиска по индексу одинакова независимо от того, какой столбец(ы) индекса используются условиями запроса. Единственная причина иметь несколько индексов BRIN вместо одного многостолбцового индекса BRIN в одной таблице — иметь другой параметр хранения pages_per_range.</p><p>Разумеется, каждый столбец должен использоваться с операторами, соответствующими типу индекса; предложения, включающие другие операторы, рассматриваться не будут.</p><p>Многоколоночные индексы следует использовать экономно. В большинстве случаев индекса по одному столбцу достаточно, он экономит место и время. Индексы с более чем тремя столбцами вряд ли будут полезны, если только использование таблицы не является чрезвычайно стилизованным. См. также раздел 11.5 и раздел 11.9 для некоторого обсуждения достоинств различных конфигураций индекса.</p>

<h2>11.4. Indexes and ORDER BY #</h2>
<p>Помимо простого поиска строк, которые должны быть возвращены запросом, индекс может быть способен доставлять их в определенном отсортированном порядке. Это позволяет соблюдать спецификацию ORDER BY запроса без отдельного шага сортировки. Из типов индексов, которые в настоящее время поддерживаются PostgreSQL, только B-tree может создавать отсортированный вывод — другие типы индексов возвращают соответствующие строки в неопределенном, зависящем от реализации порядке.</p><p>Планировщик рассмотрит возможность удовлетворения спецификации ORDER BY либо путем сканирования доступного индекса, соответствующего спецификации, либо путем сканирования таблицы в физическом порядке и выполнения явной сортировки. Для запроса, требующего сканирования большой части таблицы, явная сортировка, скорее всего, будет быстрее, чем использование индекса, поскольку она требует меньше дискового ввода-вывода из-за следования последовательному шаблону доступа. Индексы более полезны, когда нужно извлечь только несколько строк. Важным особым случаем является ORDER BY в сочетании с LIMIT n: явная сортировка должна будет обработать все данные, чтобы идентифицировать первые n строк, но если есть индекс, соответствующий ORDER BY, первые n строк можно извлечь напрямую, вообще не сканируя остаток.</p><p>По умолчанию индексы B-дерева хранят свои записи в порядке возрастания, причем последние — это null (таблица TID рассматривается как столбец-разрешитель среди других равных записей). Это означает, что прямое сканирование индекса по столбцу x дает вывод, удовлетворяющий ORDER BY x (или более подробно, ORDER BY x ASC NULLS LAST). Индекс также можно сканировать в обратном направлении, получая вывод, удовлетворяющий ORDER BY x DESC (или более подробно, ORDER BY x DESC NULLS FIRST, поскольку NULLS FIRST — это значение по умолчанию для ORDER BY DESC).</p><p>Вы можете настроить порядок индекса B-дерева, включив параметры ASC, DESC, NULLS FIRST и/или NULLS LAST при создании индекса, например:</p><pre>
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
</pre>

<p>Индекс, хранящийся в порядке возрастания, начиная с нулей, может удовлетворять либо ORDER BY x ASC NULLS FIRST, либо ORDER BY x DESC NULLS LAST в зависимости от того, в каком направлении он сканируется.</p><p>Вы можете задаться вопросом, зачем предоставлять все четыре варианта, когда два варианта вместе с возможностью обратного сканирования покрыли бы все варианты ORDER BY. В одностолбцовых индексах эти варианты действительно избыточны, но в многостолбцовых индексах они могут быть полезны. Рассмотрим двухстолбцовый индекс по (x, y): он может удовлетворить ORDER BY x, y, если мы сканируем вперед, или ORDER BY x DESC, y DESC, если мы сканируем назад. Но может оказаться, что приложению часто нужно использовать ORDER BY x ASC, y DESC. Нет способа получить такое упорядочение из простого индекса, но это возможно, если индекс определен как (x ASC, y DESC) или (x DESC, y ASC).</p><p>Очевидно, что индексы с нестандартными порядками сортировки являются довольно специализированной функцией, но иногда они могут давать колоссальное ускорение для определенных запросов. Стоит ли поддерживать такой индекс, зависит от того, как часто вы используете запросы, требующие особого порядка сортировки.</p>

<h2>11.5. Combining Multiple Indexes #</h2>
<p>Одиночное сканирование индекса может использовать только те предложения запроса, которые используют столбцы индекса с операторами его класса операторов и соединены с помощью AND. Например, при наличии индекса по (a, b) условие запроса типа WHERE a = 5 AND b = 6 может использовать индекс, но запрос типа WHERE a = 5 OR b = 6 не может напрямую использовать индекс.</p><p>К счастью, PostgreSQL может объединять несколько индексов (включая многократное использование одного и того же индекса) для обработки случаев, которые не могут быть реализованы одним сканированием индекса. Система может формировать условия AND и OR для нескольких сканирований индекса. Например, запрос типа WHERE x = 42 OR x = 47 OR x = 53 OR x = 99 можно разбить на четыре отдельных сканирования индекса по x, каждое сканирование с использованием одного из предложений запроса. Затем результаты этих сканирований объединяются с помощью OR для получения результата. Другой пример: если у нас есть отдельные индексы по x и y, одной из возможных реализаций запроса типа WHERE x = 5 AND y = 6 является использование каждого индекса с соответствующим предложением запроса, а затем объединение результатов индекса с помощью AND для идентификации строк результата.</p><p>Чтобы объединить несколько индексов, система сканирует каждый необходимый индекс и подготавливает битовую карту в памяти, указывающую расположение строк таблицы, которые, как сообщается, соответствуют условиям этого индекса. Затем битовые карты объединяются с помощью операций AND и OR, как того требует запрос. Наконец, фактические строки таблицы посещаются и возвращаются. Строки таблицы посещаются в физическом порядке, потому что именно так организована битовая карта; это означает, что любой порядок исходных индексов теряется, и поэтому потребуется отдельный шаг сортировки, если запрос содержит предложение ORDER BY. По этой причине, а также потому, что каждое дополнительное сканирование индекса добавляет дополнительное время, планировщик иногда выбирает использовать простое сканирование индекса, даже если доступны дополнительные индексы, которые также можно было бы использовать.</p><p>Во всех приложениях, кроме самых простых, существуют различные комбинации индексов, которые могут быть полезны, и разработчик базы данных должен пойти на компромиссы, чтобы решить, какие индексы предоставить. Иногда многоколоночные индексы являются лучшими, но иногда лучше создать отдельные индексы и положиться на функцию объединения индексов. Например, если ваша рабочая нагрузка включает смесь запросов, которые иногда включают только столбец x, иногда только столбец y, а иногда оба столбца, вы можете выбрать создание двух отдельных индексов по x и y, полагаясь на комбинацию индексов для обработки запросов, которые используют оба столбца. Вы также можете создать многоколоночный индекс по (x, y). Этот индекс, как правило, будет более эффективным, чем комбинация индексов для запросов, включающих оба столбца, но, как обсуждалось в разделе 11.3, он будет почти бесполезен для запросов, включающих только y, поэтому он не должен быть единственным индексом. Комбинация многоколоночного индекса и отдельного индекса по y будет работать достаточно хорошо. Для запросов, включающих только x, можно использовать многоколоночный индекс, хотя он будет больше и, следовательно, медленнее, чем индекс только по x. Последняя альтернатива — создать все три индекса, но это, вероятно, разумно только в том случае, если таблица просматривается гораздо чаще, чем обновляется, и все три типа запросов являются общими. Если один из типов запросов встречается гораздо реже других, вы, вероятно, согласитесь создать только два индекса, которые лучше всего соответствуют общим типам.</p>

<h2>11.6. Unique Indexes #</h2>
<p>Индексы также можно использовать для обеспечения уникальности значения столбца или уникальности объединенных значений более чем одного столбца.</p><pre>
CREATE UNIQUE INDEX name ON table (column [, ...]) [ NULLS [ NOT ] DISTINCT ];
</pre>

<p>В настоящее время уникальными могут быть объявлены только индексы B-дерева.</p><p>Если индекс объявлен уникальным, несколько строк таблицы с одинаковыми индексированными значениями не допускаются. По умолчанию нулевые значения в уникальном столбце не считаются равными, что позволяет иметь несколько нулевых значений в столбце. Параметр NULLS NOT DISTINCT изменяет это и заставляет индекс обрабатывать нулевые значения как равные. Многостолбцовый уникальный индекс будет отклонять только случаи, когда все индексированные столбцы равны в нескольких строках.</p><p>PostgreSQL автоматически создает уникальный индекс, когда для таблицы определено уникальное ограничение или первичный ключ. Индекс охватывает столбцы, составляющие первичный ключ или уникальное ограничение (многостолбцовый индекс, если применимо), и является механизмом, который обеспечивает соблюдение ограничения.</p><p>Нет необходимости вручную создавать индексы для уникальных столбцов; это просто приведет к дублированию автоматически созданного индекса.</p>

<h2>11.7. Indexes on Expressions #</h2>
<p>Индексный столбец не обязательно должен быть просто столбцом базовой таблицы, но может быть функцией или скалярным выражением, вычисленным из одного или нескольких столбцов таблицы. Эта функция полезна для получения быстрого доступа к таблицам на основе результатов вычислений.</p><p>Например, распространенным способом выполнения сравнений без учета регистра является использование функции lower:</p><pre>
SELECT * FROM test1 WHERE lower(col1) = 'value';
</pre>

<p>Этот запрос может использовать индекс, если он был определен для результата функции lower(col1):</p><pre>
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
</pre>

<p>Если бы мы объявили этот индекс UNIQUE, это предотвратило бы создание строк, значения col1 которых отличаются только регистром, а также строк, значения col1 которых фактически идентичны. Таким образом, индексы выражений могут использоваться для обеспечения ограничений, которые не определяются как простые уникальные ограничения.</p><p>Другой пример: если часто делать такие запросы:</p><pre>
SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';
</pre>

<p>то, возможно, стоит создать такой индекс:</p><pre>
CREATE INDEX people_names ON people ((first_name || ' ' || last_name));
</pre>

<p>Синтаксис команды CREATE INDEX обычно требует написания скобок вокруг выражений индекса, как показано во втором примере. Скобки можно опустить, если выражение представляет собой просто вызов функции, как в первом примере.</p><p>Индексные выражения относительно дороги в обслуживании, поскольку производные выражения должны вычисляться для каждой вставки строки и не-HOT обновления. Однако индексные выражения не пересчитываются во время индексированного поиска, поскольку они уже сохранены в индексе. В обоих приведенных выше примерах система видит запрос просто как WHERE indexedcolumn = 'constant', и поэтому скорость поиска эквивалентна любому другому простому индексному запросу. Таким образом, индексы по выражениям полезны, когда скорость извлечения важнее скорости вставки и обновления.</p>


<h2>11.8. Partial Indexes #</h2>
<p>Частичный индекс — это индекс, построенный по подмножеству таблицы; подмножество определяется условным выражением (называемым предикатом частичного индекса). Индекс содержит записи только для тех строк таблицы, которые удовлетворяют предикату. Частичные индексы — это специализированная функция, но есть несколько ситуаций, в которых они полезны.</p><p>Одной из основных причин использования частичного индекса является избежание индексации общих значений. Поскольку запрос, ищущий общее значение (которое составляет более нескольких процентов всех строк таблицы), в любом случае не будет использовать индекс, нет смысла вообще хранить эти строки в индексе. Это уменьшает размер индекса, что ускорит те запросы, которые используют индекс. Это также ускорит многие операции обновления таблиц, поскольку индекс не нужно обновлять во всех случаях. Пример 11.1 показывает возможное применение этой идеи.</p><p>Пример 11.1. Настройка частичного индекса для исключения общих значений</p><p>Предположим, что вы храните журналы доступа к веб-серверу в базе данных. Большинство обращений исходят из диапазона IP-адресов вашей организации, но некоторые — из других мест (например, сотрудники, подключенные по коммутируемой линии). Если ваши поиски по IP в основном направлены на внешние обращения, вам, вероятно, не нужно индексировать диапазон IP-адресов, соответствующий подсети вашей организации.</p><p>Предположим, что таблица выглядит следующим образом:</p><pre>
CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);
</pre>

<p>Чтобы создать частичный индекс, подходящий для нашего примера, используйте такую ​​команду:</p><pre>
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip > inet '192.168.100.0' AND
           client_ip < inet '192.168.100.255');
</pre>

<p>Типичный запрос, который может использовать этот индекс, будет выглядеть так:</p><pre>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
</pre>

<p>Здесь IP-адрес запроса охватывается частичным индексом. Следующий запрос не может использовать частичный индекс, так как он использует IP-адрес, который исключен из индекса:</p><pre>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '192.168.100.23';
</pre>

<p>Обратите внимание, что этот тип частичного индекса требует, чтобы общие значения были предопределены, поэтому такие частичные индексы лучше всего использовать для распределений данных, которые не меняются. Такие индексы можно время от времени пересоздавать для корректировки новых распределений данных, но это добавляет усилий по обслуживанию.</p><p>Другое возможное использование частичного индекса — исключить из индекса значения, которые не интересуют типичную рабочую нагрузку запроса; это показано в примере 11.2. Это приводит к тем же преимуществам, что перечислены выше, но предотвращает доступ к «неинтересным» значениям через этот индекс, даже если сканирование индекса может быть прибыльным в этом случае. Очевидно, что настройка частичных индексов для такого рода сценариев потребует большой осторожности и экспериментов.</p><p>Пример 11.2. Настройка частичного индекса для исключения неинтересных значений</p><p>Если у вас есть таблица, которая содержит как выставленные, так и не выставленные заказы, где не выставленные заказы занимают небольшую часть всей таблицы, и тем не менее это наиболее используемые строки, вы можете повысить производительность, создав индекс только для не выставленных строк. Команда для создания индекса будет выглядеть следующим образом:</p><pre>
CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;
</pre>

<p>Возможный запрос для использования этого индекса будет следующим:</p><pre>
SELECT * FROM orders WHERE billed is not true AND order_nr < 10000;
</pre>

<p>Однако индекс можно использовать и в запросах, которые вообще не включают order_nr, например:</p><pre>
SELECT * FROM orders WHERE billed is not true AND amount > 5000.00;
</pre>

<p>Это не так эффективно, как частичный индекс по столбцу суммы, поскольку система должна сканировать весь индекс. Тем не менее, если не выставленных счетов заказов относительно немного, использование этого частичного индекса только для поиска не выставленных счетов заказов может быть выигрышем.</p><p>Обратите внимание, что этот запрос не может использовать этот индекс:</p><pre>
SELECT * FROM orders WHERE order_nr = 3501;
</pre>

<p>Заказ 3501 может быть среди выставленных или не выставленных счетов.</p><p>Пример 11.2 также иллюстрирует, что индексированный столбец и столбец, используемый в предикате, не обязательно должны совпадать. PostgreSQL поддерживает частичные индексы с произвольными предикатами, если задействованы только столбцы индексируемой таблицы. Однако имейте в виду, что предикат должен соответствовать условиям, используемым в запросах, которые должны извлечь выгоду из индекса. Если быть точным, частичный индекс может использоваться в запросе, только если система может распознать, что условие WHERE запроса математически подразумевает предикат индекса. PostgreSQL не имеет сложного доказательного средства теорем, которое может распознавать математически эквивалентные выражения, записанные в разных формах. (Такое общее доказательное средство теорем не только чрезвычайно сложно создать, оно, вероятно, будет слишком медленным, чтобы быть реально полезным.) Система может распознавать простые следствия неравенства, например, «x < 1» подразумевает «x < 2»; в противном случае условие предиката должно точно соответствовать части условия WHERE запроса, иначе индекс не будет распознан как пригодный для использования. Сопоставление происходит во время планирования запроса, а не во время выполнения. В результате параметризованные предложения запроса не работают с частичным индексом. Например, подготовленный запрос с параметром может указывать «x < ?», что никогда не будет подразумевать «x < 2» для всех возможных значений параметра.</p><p>Третье возможное использование частичных индексов вообще не требует использования индекса в запросах. Идея здесь заключается в создании уникального индекса по подмножеству таблицы, как в примере 11.3. Это обеспечивает уникальность среди строк, которые удовлетворяют предикату индекса, не ограничивая те, которые не удовлетворяют.</p><p>Пример 11.3. Настройка частичного уникального индекса</p><p>Предположим, что у нас есть таблица, описывающая результаты теста. Мы хотим гарантировать, что для данной комбинации субъекта и цели есть только одна «успешная» запись, но может быть любое количество «неуспешных» записей. Вот один из способов сделать это:</p><pre>
CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</pre>

<p>Это особенно эффективный подход, когда успешных тестов мало, а неудачных много. Также можно разрешить только один null в столбце, создав уникальный частичный индекс с ограничением IS NULL.</p><p>Наконец, частичный индекс также может использоваться для переопределения выбора плана запроса системы. Кроме того, наборы данных с особым распределением могут заставить систему использовать индекс, когда на самом деле этого делать не следует. В этом случае индекс можно настроить так, чтобы он был недоступен для нарушающего запроса. Обычно PostgreSQL делает разумный выбор относительно использования индекса (например, он избегает их при извлечении общих значений, поэтому предыдущий пример на самом деле только экономит размер индекса, избегать использования индекса не требуется), а грубо неправильный выбор плана является причиной отчета об ошибке.</p><p>Помните, что настройка частичного индекса означает, что вы знаете по крайней мере столько же, сколько знает планировщик запросов, в частности, вы знаете, когда индекс может быть прибыльным. Формирование этих знаний требует опыта и понимания того, как работают индексы в PostgreSQL. В большинстве случаев преимущество частичного индекса над обычным индексом будет минимальным. Есть случаи, когда они совершенно контрпродуктивны, как в примере 11.4.</p><p>Пример 11.4. Не используйте частичные индексы в качестве замены разбиения на разделы</p><p>У вас может возникнуть соблазн создать большой набор непересекающихся частичных индексов, например</p><pre>
CREATE INDEX mytable_cat_1 ON mytable (data) WHERE category = 1;
CREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;
CREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;
...
CREATE INDEX mytable_cat_N ON mytable (data) WHERE category = N;
</pre>

<p>Это плохая идея! Почти наверняка вам будет лучше с одним нечастичным индексом, объявленным как</p><pre>
CREATE INDEX mytable_cat_data ON mytable (category, data);
</pre>

<p>(Поставьте столбец категории первым по причинам, описанным в разделе 11.3.) Хотя поиск в этом большем индексе может потребовать спуска на пару уровней дерева больше, чем поиск в меньшем индексе, это почти наверняка будет дешевле, чем усилия планировщика, необходимые для выбора подходящего одного из частичных индексов. Суть проблемы в том, что система не понимает взаимосвязи между частичными индексами и будет кропотливо проверять каждый из них, чтобы увидеть, применим ли он к текущему запросу.</p><p>Если ваша таблица настолько велика, что один индекс действительно плохая идея, вам следует рассмотреть возможность использования секционирования (см. раздел 5.12). Благодаря этому механизму система понимает, что таблицы и индексы не перекрываются, поэтому возможна более высокая производительность.</p><p>Более подробную информацию о частичных индексах можно найти в [ston89b], [olson93] и [seshadri95].</p>

<h2>11.9. Index-Only Scans and Covering Indexes #</h2>
<p>Все индексы в PostgreSQL являются вторичными индексами, что означает, что каждый индекс хранится отдельно от основной области данных таблицы (которая в терминологии PostgreSQL называется кучей таблицы). Это означает, что при обычном сканировании индекса каждое извлечение строки требует извлечения данных как из индекса, так и из кучи. Кроме того, хотя записи индекса, соответствующие заданному индексируемому условию WHERE, обычно находятся близко друг к другу в индексе, строки таблицы, на которые они ссылаются, могут находиться в любом месте кучи. Таким образом, часть сканирования индекса, связанная с доступом к куче, включает в себя множество случайных доступов к куче, что может быть медленным, особенно на традиционных вращающихся носителях. (Как описано в разделе 11.5, сканирование битовых карт пытается снизить эти затраты, выполняя доступ к куче в отсортированном порядке, но это лишь часть.)</p><p>Чтобы решить эту проблему производительности, PostgreSQL поддерживает сканирование только индекса, которое может отвечать на запросы только из индекса без какого-либо доступа к куче. Основная идея заключается в том, чтобы возвращать значения непосредственно из каждой записи индекса вместо того, чтобы обращаться к связанной записи кучи. Существует два основных ограничения на то, когда можно использовать этот метод:</p><p>Тип индекса должен поддерживать только индексное сканирование. Индексы B-tree всегда поддерживают. Индексы GiST и SP-GiST поддерживают только индексное сканирование для некоторых классов операторов, но не для других. Другие типы индексов не поддерживаются. Базовое требование заключается в том, что индекс должен физически хранить или иметь возможность реконструировать исходное значение данных для каждой записи индекса. В качестве контрпримера, индексы GIN не могут поддерживать только индексное сканирование, поскольку каждая запись индекса обычно содержит только часть исходного значения данных.</p><p>Запрос должен ссылаться только на столбцы, хранящиеся в индексе. Например, если задан индекс по столбцам x и y таблицы, которая также имеет столбец z, эти запросы могут использовать сканирование только индекса:</p><pre>
SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y < 42;
</pre>

<p>но эти запросы не смогли:</p><pre>
SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z < 42;
</pre>

<p>(Индексы выражений и частичные индексы усложняют это правило, как обсуждается ниже.)</p><p>Если эти два основных требования выполнены, то все значения данных, требуемые запросом, доступны из индекса, поэтому сканирование только индекса физически возможно. Но есть дополнительное требование для любого сканирования таблицы в PostgreSQL: оно должно проверять, что каждая извлеченная строка «видима» для снимка MVCC запроса, как обсуждалось в Главе 13. Информация о видимости не хранится в записях индекса, только в записях кучи; поэтому на первый взгляд может показаться, что каждое извлечение строки в любом случае потребует доступа к куче. И это действительно так, если строка таблицы была недавно изменена. Однако для редко меняющихся данных есть способ обойти эту проблему. PostgreSQL отслеживает для каждой страницы в куче таблицы, являются ли все строки, хранящиеся на этой странице, достаточно старыми, чтобы быть видимыми для всех текущих и будущих транзакций. Эта информация хранится в бите в карте видимости таблицы. Сканирование только индекса после нахождения потенциальной записи индекса проверяет бит карты видимости для соответствующей страницы кучи. Если он установлен, строка известна как видимая, и поэтому данные могут быть возвращены без дополнительной работы. Если он не установлен, необходимо посетить запись кучи, чтобы выяснить, видима ли она, поэтому никакого преимущества в производительности по сравнению со стандартным сканированием индекса не достигается. Даже в успешном случае этот подход обменивает доступ к карте видимости на доступ к куче; но поскольку карта видимости на четыре порядка меньше кучи, которую она описывает, для доступа к ней требуется гораздо меньше физического ввода-вывода. В большинстве ситуаций карта видимости все время остается кэшированной в памяти.</p><p>Короче говоря, хотя сканирование только индекса возможно с учетом двух основных требований, оно будет выигрышным только в том случае, если значительная часть страниц кучи таблицы имеет установленные биты отображения всех видимых данных. Но таблицы, в которых большая часть строк не изменяется, достаточно распространены, чтобы сделать этот тип сканирования очень полезным на практике.</p><p>Чтобы эффективно использовать функцию сканирования только индекса, вы можете создать покрывающий индекс, который является индексом, специально разработанным для включения столбцов, необходимых для определенного типа запроса, который вы часто запускаете. Поскольку запросы обычно должны извлекать больше столбцов, чем просто те, по которым они ищут, PostgreSQL позволяет вам создать индекс, в котором некоторые столбцы являются просто «полезной нагрузкой» и не являются частью ключа поиска. Это делается путем добавления предложения INCLUDE, перечисляющего дополнительные столбцы. Например, если вы часто запускаете такие запросы, как</p><pre>
SELECT y FROM tab WHERE x = 'key';
</pre>

<p>Традиционный подход к ускорению таких запросов заключается в создании индекса только по x. Однако индекс, определенный как</p><pre>
CREATE INDEX tab_x_y ON tab(x) INCLUDE (y);
</pre>

<p>может обрабатывать эти запросы как сканирование только индекса, поскольку y можно получить из индекса без обращения к куче.</p><p>Поскольку столбец y не является частью ключа поиска индекса, он не обязательно должен быть типом данных, который индекс может обработать; он просто хранится в индексе и не интерпретируется индексным механизмом. Кроме того, если индекс является уникальным индексом, то есть</p><pre>
CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);
</pre>

<p>условие уникальности применяется только к столбцу x, а не к комбинации x и y. (Предложение INCLUDE также может быть записано в ограничениях UNIQUE и PRIMARY KEY, предоставляя альтернативный синтаксис для настройки такого индекса.)</p><p>Разумно быть осторожным при добавлении неключевых столбцов полезной нагрузки в индекс, особенно широких столбцов. Если кортеж индекса превышает максимально допустимый размер для типа индекса, вставка данных не удастся. В любом случае неключевые столбцы дублируют данные из таблицы индекса и увеличивают размер индекса, что потенциально замедляет поиск. И помните, что нет смысла включать столбцы полезной нагрузки в индекс, если таблица не изменяется достаточно медленно, так что сканированию только индекса, скорее всего, не понадобится доступ к куче. Если кортеж кучи в любом случае необходимо посетить, то получить значение столбца оттуда ничего не стоит. Другие ограничения заключаются в том, что выражения в настоящее время не поддерживаются как включенные столбцы, и что в настоящее время включенные столбцы поддерживаются только индексами B-tree, GiST и SP-GiST.</p><p>До того, как в PostgreSQL появилась функция INCLUDE, люди иногда создавали покрывающие индексы, записывая столбцы полезной нагрузки как обычные столбцы индекса, то есть записывая</p><pre>
CREATE INDEX tab_x_y ON tab(x, y);
</pre>

<p>даже если они не собирались когда-либо использовать y как часть предложения WHERE. Это работает нормально, пока дополнительные столбцы являются конечными столбцами; делать их ведущими столбцами неразумно по причинам, изложенным в разделе 11.3. Однако этот метод не поддерживает случай, когда вы хотите, чтобы индекс обеспечивал уникальность ключевых столбцов.</p><p>Усечение суффикса всегда удаляет неключевые столбцы из верхних уровней B-Tree. Как столбцы полезной нагрузки, они никогда не используются для руководства сканированием индекса. Процесс усечения также удаляет один или несколько конечных ключевых столбцов, когда оставшийся префикс ключевых столбцов оказывается достаточным для описания кортежей на самом нижнем уровне B-Tree. На практике покрывающие индексы без предложения INCLUDE часто избегают хранения столбцов, которые фактически являются полезной нагрузкой на верхних уровнях. Однако явное определение столбцов полезной нагрузки как неключевых столбцов надежно сохраняет кортежи на верхних уровнях небольшими.</p><p>В принципе, сканирование только индекса может использоваться с индексами выражений. Например, если задан индекс на f(x), где x — столбец таблицы, должно быть возможно выполнить</p><pre>
SELECT f(x) FROM tab WHERE f(x) < 1;
</pre>

<p>как сканирование только индекса; и это очень привлекательно, если f() является дорогой для вычисления функцией. Однако планировщик PostgreSQL в настоящее время не очень умен в таких случаях. Он считает запрос потенциально исполняемым сканированием только индекса только тогда, когда все столбцы, необходимые запросу, доступны из индекса. В этом примере x не требуется, за исключением контекста f(x), но планировщик не замечает этого и приходит к выводу, что сканирование только индекса невозможно. Если сканирование только индекса кажется достаточно стоящим, это можно обойти, добавив x как включенный столбец, например</p><pre>
CREATE INDEX tab_f_x ON tab (f(x)) INCLUDE (x);
</pre>

<p>Дополнительное предостережение, если цель состоит в том, чтобы избежать пересчета f(x), заключается в том, что планировщик не обязательно будет сопоставлять использования f(x), которые не находятся в индексируемых предложениях WHERE, со столбцом индекса. Обычно это будет сделано правильно в простых запросах, таких как показанный выше, но не в запросах, которые включают соединения. Эти недостатки могут быть устранены в будущих версиях PostgreSQL.</p><p>Частичные индексы также имеют интересные взаимодействия с сканированиями только индексов. Рассмотрим частичный индекс, показанный в примере 11.3:</p><pre>
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</pre>

<p>В принципе, мы могли бы выполнить сканирование только индекса по этому индексу, чтобы удовлетворить такой запрос, как</p><pre>
SELECT target FROM tests WHERE subject = 'some-subject' AND success;
</pre>

<p>Но есть проблема: предложение WHERE ссылается на success, который недоступен как столбец результата индекса. Тем не менее, сканирование только индекса возможно, поскольку плану не нужно перепроверять эту часть предложения WHERE во время выполнения: все записи, найденные в индексе, обязательно имеют success = true, поэтому это не нужно явно проверять в плане. Версии PostgreSQL 9.6 и более поздние распознают такие случаи и позволяют генерировать сканирование только индекса, но более старые версии этого не делают.</p>

<h2>11.10. Operator Classes and Operator Families #</h2>
<p>Определение индекса может указывать класс операторов для каждого столбца индекса.</p><pre>
CREATE INDEX name ON table (column opclass [ ( opclass_options ) ] [sort options] [, ...]);
</pre>

<p>Класс операторов определяет операторы, которые будут использоваться индексом для этого столбца. Например, индекс B-дерева для типа int4 будет использовать класс int4_ops; этот класс операторов включает функции сравнения для значений типа int4. На практике класса операторов по умолчанию для типа данных столбца обычно достаточно. Основная причина наличия классов операторов заключается в том, что для некоторых типов данных может быть более одного значимого поведения индекса. Например, мы можем захотеть отсортировать тип данных комплексного числа либо по абсолютному значению, либо по действительной части. Мы могли бы сделать это, определив два класса операторов для типа данных, а затем выбрав правильный класс при создании индекса. Класс операторов определяет базовый порядок сортировки (который затем можно изменить, добавив параметры сортировки COLLATE, ASC/DESC и/или NULLS FIRST/NULLS LAST).</p><p>Помимо стандартных классов операторов, существуют также некоторые встроенные классы операторов:</p><p>Классы операторов text_pattern_ops, varchar_pattern_ops и bpchar_pattern_ops поддерживают индексы B-tree для типов text, varchar и char соответственно. Отличие от классов операторов по умолчанию заключается в том, что значения сравниваются строго посимвольно, а не в соответствии с правилами сортировки, специфичными для локали. Это делает эти классы операторов подходящими для использования в запросах, включающих выражения сопоставления с шаблоном (регулярные выражения LIKE или POSIX), когда база данных не использует стандартную локаль «C». Например, вы можете индексировать столбец varchar следующим образом:</p><pre>
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
</pre>

<p>Обратите внимание, что вам также следует создать индекс с классом оператора по умолчанию, если вы хотите, чтобы запросы, включающие обычные сравнения <, <=, > или >=, использовали индекс. Такие запросы не могут использовать классы операторов xxx_pattern_ops. (Однако обычные сравнения на равенство могут использовать эти классы операторов.) Можно создать несколько индексов для одного столбца с разными классами операторов. Если вы используете локаль C, вам не нужны классы операторов xxx_pattern_ops, поскольку индекс с классом оператора по умолчанию можно использовать для запросов на сопоставление с шаблоном в локали C.</p><p>Следующий запрос показывает все определенные классы операторов:</p><pre>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;
</pre>

<p>Класс операторов на самом деле является просто подмножеством более крупной структуры, называемой семейством операторов. В случаях, когда несколько типов данных имеют схожее поведение, часто бывает полезно определить операторы кросс-типов данных и разрешить им работать с индексами. Для этого классы операторов для каждого из типов должны быть сгруппированы в одно и то же семейство операторов. Операторы кросс-типов являются членами семейства, но не связаны ни с одним классом в пределах семейства.</p><p>Эта расширенная версия предыдущего запроса показывает семейство операторов, к которому принадлежит каждый класс операторов:</p><pre>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opf.opfname AS opfamily_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc, pg_opfamily opf
    WHERE opc.opcmethod = am.oid AND
          opc.opcfamily = opf.oid
    ORDER BY index_method, opclass_name;
</pre>

<p>Этот запрос показывает все определенные семейства операторов и всех операторов, включенных в каждое семейство:</p><pre>
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
</pre>

<p>В psql есть команды \dAc, \dAf и \dAo, которые предоставляют немного более сложные версии этих запросов.</p>

<h2>11.11. Indexes and Collations #</h2>
<p>Индекс может поддерживать только одну сортировку на столбец индекса. Если интерес представляют несколько сортировок, может потребоваться несколько индексов.</p><p>Рассмотрим следующие утверждения:</p><pre>
CREATE TABLE test1c (
    id integer,
    content varchar COLLATE "x"
);

CREATE INDEX test1c_content_index ON test1c (content);
</pre>

<p>Индекс автоматически использует сортировку базового столбца. Поэтому запрос вида</p><pre>
SELECT * FROM test1c WHERE content > constant;
</pre>

<p>можно использовать индекс, потому что сравнение по умолчанию будет использовать сортировку столбца. Однако этот индекс не может ускорить запросы, которые включают какую-то другую сортировку. Так что если запросы формы, скажем,</p><pre>
SELECT * FROM test1c WHERE content > constant COLLATE "y";
</pre>

<p>также представляют интерес, можно создать дополнительный индекс, поддерживающий сортировку "y", например:</p><pre>
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");
</pre>



<h2>11.12. Examining Index Usage #</h2>
<p>Хотя индексы в PostgreSQL не нуждаются в обслуживании или настройке, все равно важно проверять, какие индексы фактически используются реальной рабочей нагрузкой запросов. Проверка использования индекса для отдельного запроса выполняется с помощью команды EXPLAIN; ее применение для этой цели проиллюстрировано в разделе 14.1. Также можно собрать общую статистику об использовании индекса на работающем сервере, как описано в разделе 27.2.</p><p>Трудно сформулировать общую процедуру для определения того, какие индексы создавать. Существует ряд типичных случаев, которые были показаны в примерах в предыдущих разделах. Часто необходимо много экспериментировать. Остальная часть этого раздела дает несколько советов для этого:</p><p>Всегда сначала запускайте ANALYZE. Эта команда собирает статистику о распределении значений в таблице. Эта информация необходима для оценки количества строк, возвращаемых запросом, что необходимо планировщику для назначения реалистичных затрат каждому возможному плану запроса. При отсутствии какой-либо реальной статистики предполагаются некоторые значения по умолчанию, которые почти наверняка будут неточными. Таким образом, проверка использования индекса приложением без запуска ANALYZE является безнадежным делом. Для получения дополнительной информации см. Раздел 24.1.3 и Раздел 24.1.6.</p><p>Используйте реальные данные для экспериментов. Использование тестовых данных для настройки индексов покажет вам, какие индексы вам нужны для тестовых данных, но это все.</p><p>Особенно губительно использовать очень маленькие наборы тестовых данных. В то время как выбор 1000 из 100000 строк может быть кандидатом на индекс, выбор 1 из 100 строк вряд ли будет таковым, поскольку 100 строк, вероятно, поместятся на одной странице диска, и нет плана, который мог бы превзойти последовательное извлечение 1 страницы диска.</p><p>Также будьте осторожны при составлении тестовых данных, что часто неизбежно, когда приложение еще не запущено в эксплуатацию. Значения, которые очень похожи, полностью случайны или вставлены в отсортированном порядке, исказят статистику от распределения, которое имели бы реальные данные.</p><p>Когда индексы не используются, может быть полезно для тестирования принудительно использовать их. Существуют параметры времени выполнения, которые могут отключать различные типы планов (см. раздел 19.7.1). Например, отключение последовательного сканирования (enable_seqscan) и соединений вложенных циклов (enable_nestloop), которые являются самыми базовыми планами, заставит систему использовать другой план. Если система по-прежнему выбирает последовательное сканирование или соединение вложенных циклов, то, вероятно, есть более фундаментальная причина, по которой индекс не используется; например, условие запроса не соответствует индексу. (Какой тип запроса может использовать какой тип индекса, объясняется в предыдущих разделах.)</p><p>Если принудительное использование индекса действительно использует индекс, то есть две возможности: либо система права и использование индекса действительно нецелесообразно, либо оценки стоимости планов запросов не отражают реальность. Поэтому вам следует рассчитать время выполнения запроса с индексами и без них. Команда EXPLAIN ANALYZE может быть здесь полезна.</p><p>Если окажется, что оценки стоимости неверны, то снова есть две возможности. Общая стоимость вычисляется из затрат на строку каждого узла плана, умноженных на оценку селективности узла плана. Оценки стоимости для узлов плана можно скорректировать с помощью параметров времени выполнения (описанных в разделе 19.7.2). Неточная оценка селективности возникает из-за недостаточной статистики. Это можно улучшить, настроив параметры сбора статистики (см. ALTER TABLE).</p><p>Если вам не удастся скорректировать затраты на более приемлемые, то вам, возможно, придется прибегнуть к явному принудительному использованию индекса. Вы также можете обратиться к разработчикам PostgreSQL для изучения проблемы.</p>

