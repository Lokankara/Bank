<h2>64.2. GiST Indexes #</h2>
<p>GiST означает Generalized Search Tree (Обобщенное дерево поиска). Это сбалансированный, древовидный метод доступа, который действует как базовый шаблон для реализации произвольных схем индексации. B-деревья, R-деревья и многие другие схемы индексации могут быть реализованы в GiST.</p><p>Одним из преимуществ GiST является то, что он позволяет разрабатывать пользовательские типы данных с соответствующими методами доступа эксперту в области типа данных, а не эксперту по базам данных.</p><p>Часть информации здесь взята с веб-сайта проекта индексирования GiST Калифорнийского университета в Беркли и диссертации Марселя Корнакера «Методы доступа для систем баз данных следующего поколения». Реализацию GiST в PostgreSQL в основном поддерживают Теодор Сигаев и Олег Бартунов, и на их веб-сайте есть дополнительная информация.</p><p>Основной дистрибутив PostgreSQL включает классы операторов GiST, показанные в Таблице 64.1. (Некоторые из дополнительных модулей, описанных в Приложении F, предоставляют дополнительные классы операторов GiST.)</p><p>Таблица 64.1. Встроенные классы операторов GiST</p><p>По историческим причинам класс оператора inet_ops не является классом по умолчанию для типов inet и cidr. Чтобы использовать его, укажите имя класса в CREATE INDEX, например</p><p>Традиционно реализация нового метода доступа индекса означала много сложной работы. Необходимо было понять внутреннюю работу базы данных, такую ​​как менеджер блокировок и журнал упреждающей записи. Интерфейс GiST имеет высокий уровень абстракции, требуя от реализатора метода доступа только реализации семантики типа данных, к которым осуществляется доступ. Сам слой GiST заботится о параллелизме, ведении журнала и поиске в древовидной структуре.</p><p>Эту расширяемость не следует путать с расширяемостью других стандартных деревьев поиска с точки зрения данных, которые они могут обрабатывать. Например, PostgreSQL поддерживает расширяемые B-деревья и хэш-индексы. Это означает, что вы можете использовать PostgreSQL для построения B-дерева или хеша по любому типу данных, который вам нужен. Но B-деревья поддерживают только предикаты диапазона (<, =, >), а хэш-индексы поддерживают только запросы равенства.</p><p>Так что если вы индексируете, скажем, коллекцию изображений с помощью B-дерева PostgreSQL, вы можете выдавать только такие запросы, как «равно ли imagex imagey», «меньше ли imagex imagey» и «больше ли imagex imagey». В зависимости от того, как вы определяете «равно», «меньше» и «больше» в этом контексте, это может быть полезно. Однако, используя индекс на основе GiST, вы можете создать способы задавать вопросы, специфичные для предметной области, например, «найти все изображения лошадей» или «найти все переэкспонированные изображения».</p><p>Все, что нужно для запуска метода доступа GiST, — это реализовать несколько пользовательских методов, которые определяют поведение ключей в дереве. Конечно, эти методы должны быть довольно замысловатыми, чтобы поддерживать замысловатые запросы, но для всех стандартных запросов (B-деревья, R-деревья и т. д.) они относительно просты. Короче говоря, GiST сочетает в себе расширяемость с универсальностью, повторное использование кода и чистый интерфейс.</p><p>Класс оператора индекса для GiST должен предоставлять пять методов, а шесть являются необязательными. Корректность индекса обеспечивается правильной реализацией тех же самых, последовательных и объединенных методов, в то время как эффективность (размер и скорость) индекса будет зависеть от методов штрафа и picksplit. Два необязательных метода — это сжатие и распаковка, которые позволяют индексу иметь внутренние данные дерева другого типа, чем данные, которые он индексирует. Листья должны иметь индексированный тип данных, в то время как другие узлы дерева могут иметь любую структуру C (но вам все равно придется следовать правилам типов данных PostgreSQL здесь, см. о varlena для данных переменного размера). Если внутренний тип данных дерева существует на уровне SQL, можно использовать опцию STORAGE команды CREATE OPERATOR CLASS. Необязательный восьмой метод — это расстояние, которое необходимо, если класс оператора хочет поддерживать упорядоченные сканирования (поиск ближайшего соседа). Необязательный девятый метод fetch необходим, если класс оператора хочет поддерживать сканирование только индекса, за исключением случаев, когда метод compress опущен. Необязательный десятый метод options необходим, если класс оператора имеет заданные пользователем параметры. Необязательный одиннадцатый метод sortsupport используется для ускорения построения индекса GiST.</p><p>При наличии записи индекса p и значения запроса q эта функция определяет, является ли запись индекса «согласованной» с запросом; то есть может ли предикат «indexed_column indexable_operator q» быть истинным для любой строки, представленной записью индекса? Для записи индекса листа это эквивалентно проверке условия индексируемости, в то время как для внутреннего узла дерева это определяет, необходимо ли сканировать поддерево индекса, представленного узлом дерева. Когда результат истинен, также должен быть возвращен флаг повторной проверки. Это указывает, является ли предикат определенно истинным или только возможно истинным. Если recheck = false, то индекс точно проверил условие предиката, тогда как если recheck = true, то строка является только кандидатом на совпадение. В этом случае система автоматически оценит indexable_operator по фактическому значению строки, чтобы увидеть, действительно ли это совпадение. Это соглашение позволяет GiST поддерживать как без потерь, так и с потерями структуры индекса.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Здесь key — это элемент в индексе, а query — значение, искомое в индексе. Параметр StrategyNumber указывает, какой оператор вашего класса операторов применяется — он соответствует одному из номеров операторов в команде CREATE OPERATOR CLASS.</p><p>В зависимости от того, какие операторы вы включили в класс, тип данных запроса может меняться в зависимости от оператора, поскольку это будет любой тип, указанный справа от оператора, который может отличаться от индексированного типа данных, указанного слева. (Приведенный выше скелет кода предполагает, что возможен только один тип; в противном случае извлечение значения аргумента запроса должно зависеть от оператора.) Рекомендуется, чтобы в объявлении SQL согласованной функции использовался индексированный тип данных opclass для аргумента запроса, даже если фактический тип может быть другим в зависимости от оператора.</p><p>Этот метод объединяет информацию в дереве. При наличии набора записей эта функция генерирует новую запись индекса, которая представляет все заданные записи.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Как вы можете видеть, в этом скелете мы имеем дело с типом данных, где union(X, Y, Z) = union(union(X, Y), Z). Достаточно легко поддерживать типы данных, где это не так, реализовав правильный алгоритм union в этом методе поддержки GiST.</p><p>Результатом функции union должно быть значение типа хранения индекса, каким бы он ни был (он может отличаться или не отличаться от типа индексированного столбца). Функция union должна возвращать указатель на недавно выделенную palloc() память. Вы не можете просто вернуть входное значение как есть, даже если тип не был изменен.</p><p>Как показано выше, первый внутренний аргумент функции union на самом деле является указателем GistEntryVector. Второй аргумент — указатель на целочисленную переменную, которую можно игнорировать. (Раньше требовалось, чтобы функция union сохраняла размер своего результирующего значения в этой переменной, но теперь это не обязательно.)</p><p>Преобразует элемент данных в формат, подходящий для физического хранения на странице индекса. Если метод сжатия опущен, элементы данных сохраняются в индексе без изменений.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Конечно, вам придется адаптировать compress_data_type к конкретному типу, в который вы преобразуете, чтобы сжать ваши конечные узлы.</p><p>Преобразует сохраненное представление элемента данных в формат, который может быть обработан другими методами GiST в классе операторов. Если метод decompress опущен, предполагается, что другие методы GiST могут работать напрямую с сохраненным форматом данных. (decompress не обязательно является обратным методу compress; в частности, если compress с потерями, то decompress не может точно восстановить исходные данные. decompress также не обязательно эквивалентен fetch, поскольку другие методы GiST могут не требовать полной реконструкции данных.)</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Приведенный выше скелет подходит для случая, когда декомпрессия не требуется. (Но, конечно, вообще отказаться от этого метода еще проще, и это рекомендуется в таких случаях.)</p><p>Возвращает значение, указывающее «стоимость» вставки новой записи в определенную ветвь дерева. Элементы будут вставлены по пути наименьшего штрафа в дереве. Значения, возвращаемые штрафом, должны быть неотрицательными. Если возвращается отрицательное значение, оно будет рассматриваться как ноль.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>По историческим причинам функция штрафа не просто возвращает результат с плавающей точкой; вместо этого она должна сохранить значение в месте, указанном третьим аргументом. Возвращаемое значение как таковое игнорируется, хотя принято передавать обратно адрес этого аргумента.</p><p>Функция штрафа имеет решающее значение для хорошей производительности индекса. Она будет использоваться во время вставки, чтобы определить, какой ветви следовать при выборе места добавления новой записи в дерево. Во время запроса, чем более сбалансирован индекс, тем быстрее поиск.</p><p>Когда необходимо разделить страницу индекса, эта функция решает, какие записи на странице останутся на старой странице, а какие будут перенесены на новую страницу.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Обратите внимание, что результат функции picksplit доставляется путем изменения переданной структуры v. Возвращаемое значение как таковое игнорируется, хотя принято передавать обратно адрес v.</p><p>Как и штраф, функция picksplit имеет решающее значение для хорошей производительности индекса. Разработка подходящих реализаций штрафа и picksplit — вот где заключается проблема внедрения хорошо работающих индексов GiST.</p><p>Возвращает значение true, если две записи индекса идентичны, в противном случае — false. («Запись индекса» — это значение типа хранения индекса, а не обязательно тип исходного индексированного столбца.)</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>По историческим причинам та же функция не просто возвращает логический результат; вместо этого она должна сохранить флаг в месте, указанном третьим аргументом. Возвращаемое значение как таковое игнорируется, хотя принято передавать обратно адрес этого аргумента.</p><p>При наличии записи индекса p и значения запроса q эта функция определяет «расстояние» записи индекса от значения запроса. Эта функция должна быть предоставлена, если класс операторов содержит какие-либо операторы упорядочивания. Запрос с использованием оператора упорядочивания будет реализован путем возврата записей индекса с наименьшими значениями «расстояния» в первую очередь, поэтому результаты должны соответствовать семантике оператора. Для записи индекса листа результат просто представляет расстояние до записи индекса; для внутреннего узла дерева результат должен быть наименьшим расстоянием, которое может иметь любая дочерняя запись.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Аргументы функции расстояния идентичны аргументам согласованной функции.</p><p>При определении расстояния допускается некоторое приближение, при условии, что результат никогда не будет больше фактического расстояния записи. Так, например, расстояния до ограничивающего прямоугольника обычно достаточно в геометрических приложениях. Для внутреннего узла дерева возвращаемое расстояние не должно быть больше расстояния до любого из дочерних узлов. Если возвращаемое расстояние не является точным, функция должна установить *recheck в значение true. (Это не обязательно для внутренних узлов дерева; для них вычисление всегда предполагается неточным.) В этом случае исполнитель вычислит точное расстояние после извлечения кортежа из кучи и при необходимости переупорядочит кортежи.</p><p>Если функция расстояния возвращает *recheck = true для любого листового узла, тип возврата исходного оператора упорядочивания должен быть float8 или float4, а значения результата функции расстояния должны быть сопоставимы со значениями исходного оператора упорядочивания, поскольку исполнитель будет сортировать, используя как результаты функции расстояния, так и пересчитанные результаты оператора упорядочивания. В противном случае значения результата функции расстояния могут быть любыми конечными значениями float8, пока относительный порядок значений результата соответствует порядку, возвращаемому оператором упорядочивания. (Бесконечность и минус бесконечность используются внутренне для обработки таких случаев, как null, поэтому не рекомендуется, чтобы функции расстояния возвращали эти значения.)</p><p>Преобразует сжатое индексное представление элемента данных в исходный тип данных для сканирования только индекса. Возвращаемые данные должны быть точной копией без потерь исходного индексированного значения.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Аргумент — указатель на структуру GISTENTRY. При входе ее ключевое поле содержит непустые листовые данные в сжатой форме. Возвращаемое значение — другая структура GISTENTRY, ключевое поле которой содержит те же данные в исходной, несжатой форме. Если функция сжатия класса операций ничего не делает для листовых записей, метод выборки может вернуть аргумент как есть. Или, если класс операций не имеет функции сжатия, метод выборки также можно опустить, поскольку он обязательно будет пустым.</p><p>Соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Если метод сжатия приводит к потерям для конечных записей, класс оператора не может поддерживать сканирование только индекса и не должен определять функцию выборки.</p><p>Позволяет определять видимые пользователю параметры, которые управляют поведением класса оператора.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Функция передает указатель на структуру local_relopts, которую необходимо заполнить набором опций, специфичных для класса оператора. Доступ к опциям можно получить из других функций поддержки с помощью макросов PG_HAS_OPCLASS_OPTIONS() и PG_GET_OPCLASS_OPTIONS().</p><p>Ниже приведен пример реализации my_options() и использования параметров из других вспомогательных функций:</p><p>Поскольку представление ключа в GiST является гибким, оно может зависеть от указанных пользователем параметров. Например, может быть указана длина подписи ключа. См., например, gtsvector_options().</p><p>Возвращает функцию-компаратор для сортировки данных способом, сохраняющим локальность. Используется командами CREATE INDEX и REINDEX. Качество созданного индекса зависит от того, насколько хорошо порядок сортировки, определенный функцией-компаратором, сохраняет локальность входных данных.</p><p>Метод sortsupport необязателен. Если он не указан, CREATE INDEX строит индекс, вставляя каждый кортеж в дерево с использованием функций штрафа и picksplit, что намного медленнее.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Аргумент — указатель на структуру SortSupport. Как минимум, функция должна заполнить поле своего компаратора. Компаратор принимает три аргумента: два Datum для сравнения и указатель на структуру SortSupport. Datums — это два индексированных значения в том формате, в котором они хранятся в индексе; то есть в формате, возвращаемом методом compress. Полный API определен в src/include/utils/sortsupport.h.</p><p>Соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Все методы поддержки GiST обычно вызываются в краткосрочных контекстах памяти; то есть CurrentMemoryContext будет сбрасываться после обработки каждого кортежа. Поэтому не так уж важно беспокоиться о pfree'е всего, что вы palloc. Однако в некоторых случаях для метода поддержки полезно кэшировать данные между повторяющимися вызовами. Для этого выделите долгоживущие данные в fcinfo->flinfo->fn_mcxt и сохраните указатель на них в fcinfo->flinfo->fn_extra. Такие данные сохранятся в течение всего срока действия операции индексирования (например, одного сканирования индекса GiST, построения индекса или вставки кортежа индекса). Будьте осторожны, чтобы pfree предыдущего значения при замене значения fn_extra, иначе утечка будет накапливаться в течение всей операции.</p><p>Самый простой способ построить индекс GiST — просто вставить все записи одну за другой. Это обычно медленно для больших индексов, поскольку если кортежи индекса разбросаны по индексу, а индекс достаточно большой, чтобы не поместиться в кэш, потребуется много случайных операций ввода-вывода. PostgreSQL поддерживает два альтернативных метода для первоначального построения индекса GiST: сортированный и буферизованный режимы.</p><p>Метод sorted доступен только в том случае, если каждый из используемых индексом классов операций предоставляет функцию sortsupport, как описано в разделе 64.2.3. Если это так, этот метод обычно является лучшим, поэтому он используется по умолчанию.</p><p>Буферизованный метод работает, не вставляя кортежи непосредственно в индекс сразу. Он может значительно сократить количество случайных операций ввода-вывода, необходимых для неупорядоченных наборов данных. Для хорошо упорядоченных наборов данных преимущество меньше или отсутствует, поскольку только небольшое количество страниц получают новые кортежи за раз, и эти страницы помещаются в кэш, даже если индекс в целом не помещается.</p><p>Буферизованный метод должен вызывать функцию штрафа чаще, чем простой метод, что потребляет некоторые дополнительные ресурсы ЦП. Кроме того, буферам требуется временное дисковое пространство, вплоть до размера результирующего индекса. Буферизация также может влиять на качество результирующего индекса как в положительном, так и в отрицательном направлении. Это влияние зависит от различных факторов, таких как распределение входных данных и реализация класса оператора.</p><p>Если сортировка невозможна, то по умолчанию построение индекса GiST переключается на метод буферизации, когда размер индекса достигает effective_cache_size. Буферизацию можно вручную принудительно включить или предотвратить с помощью параметра буферизации в команде CREATE INDEX. Поведение по умолчанию подходит для большинства случаев, но отключение буферизации может несколько ускорить построение, если входные данные упорядочены.</p><p>Исходный дистрибутив PostgreSQL включает несколько примеров методов индексирования, реализованных с использованием GiST. В настоящее время основная система обеспечивает поддержку текстового поиска (индексирование для tsvector и tsquery), а также эквивалентную функциональность R-Tree для некоторых встроенных геометрических типов данных (см. src/backend/access/gist/gistproc.c). Следующие contrib-модули также содержат классы операторов GiST:</p><p>Эквивалентная функциональность B-дерева для нескольких типов данных</p><p>Индексация для многомерных кубов</p><p>Модуль для хранения пар (ключ, значение)</p><p>RD-Tree для одномерного массива значений int4</p><p>Индексация для древовидных структур</p><p>Сходство текста с использованием сопоставления триграмм</p><p>Индексация для «плавающих диапазонов»</p>