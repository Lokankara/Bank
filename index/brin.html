<h2>64.5. BRIN Indexes #</h2>
<p>BRIN означает Block Range Index (индекс диапазона блоков). BRIN предназначен для обработки очень больших таблиц, в которых определенные столбцы имеют некоторую естественную корреляцию с их физическим расположением внутри таблицы.</p><p>BRIN работает с точки зрения диапазонов блоков (или «диапазонов страниц»). Диапазон блоков — это группа страниц, которые физически соседствуют в таблице; для каждого диапазона блоков индексом хранится некоторая сводная информация. Например, таблица, в которой хранятся заказы магазина на продажу, может иметь столбец даты, в который был размещен каждый заказ, и в большинстве случаев записи для более ранних заказов также будут отображаться раньше в таблице; таблица, в которой хранится столбец почтового индекса, может иметь все коды для города, сгруппированные вместе естественным образом.</p><p>Индексы BRIN могут удовлетворять запросы посредством обычного сканирования индекса bitmap и возвращают все кортежи на всех страницах в каждом диапазоне, если сводная информация, хранящаяся в индексе, соответствует условиям запроса. Исполнитель запроса отвечает за повторную проверку этих кортежей и отбрасывание тех, которые не соответствуют условиям запроса — другими словами, эти индексы являются индексами с потерями. Поскольку индекс BRIN очень мал, сканирование индекса добавляет небольшие накладные расходы по сравнению с последовательным сканированием, но может избежать сканирования больших частей таблицы, которые, как известно, не содержат соответствующих кортежей.</p><p>Конкретные данные, которые будет хранить индекс BRIN, а также конкретные запросы, которые индекс сможет удовлетворить, зависят от класса операторов, выбранного для каждого столбца индекса. Типы данных, имеющие линейный порядок сортировки, могут иметь классы операторов, которые хранят минимальное и максимальное значение в пределах каждого диапазона блока, например; геометрические типы могут хранить ограничивающий прямоугольник для всех объектов в диапазоне блока.</p><p>Размер диапазона блоков определяется во время создания индекса параметром хранения pages_per_range. Количество записей индекса будет равно размеру отношения в страницах, деленному на выбранное значение pages_per_range. Таким образом, чем меньше число, тем больше становится индекс (из-за необходимости хранить больше записей индекса), но в то же время хранимые сводные данные могут быть более точными, и больше блоков данных можно пропустить во время сканирования индекса.</p><p>Во время создания все существующие страницы кучи сканируются, и для каждого диапазона создается сводная индексная запись, включая возможно неполный диапазон в конце. По мере заполнения новых страниц данными диапазоны страниц, которые уже суммированы, приведут к обновлению сводной информации данными из новых кортежей. Когда создается новая страница, которая не попадает в последний суммированный диапазон, диапазон, к которому принадлежит новая страница, автоматически не получает сводную запись; эти кортежи остаются несуммированными до тех пор, пока позже не будет вызван запуск суммирования, создающий начальную сводку для этого диапазона.</p><p>Существует несколько способов запустить начальное суммирование диапазона страниц. Если таблица очищается вручную или с помощью автоочистки, все существующие несуммированные диапазоны страниц суммируются. Кроме того, если параметр автосуммирования индекса включен, что не является таковым по умолчанию, всякий раз, когда автоочистка запускается в этой базе данных, суммирование будет выполняться для всех несуммированных диапазонов страниц, которые были заполнены, независимо от того, обрабатывается ли сама таблица с помощью автоочистки; см. ниже.</p><p>Наконец, можно использовать следующие функции (во время работы этих функций search_path временно изменяется на pg_catalog, pg_temp):</p><p>Когда включена автосуммирование, запрос отправляется в автовакуум для выполнения целевого суммирования для диапазона блоков, когда обнаруживается вставка для первого элемента первой страницы следующего диапазона блоков, которая будет выполнена в следующий раз, когда работник автовакуума закончит работу в той же базе данных. Если очередь запросов заполнена, запрос не регистрируется, а в журнал сервера отправляется сообщение:</p><p>В этом случае диапазон останется необработанным до следующего регулярного запуска вакуумной очистки таблицы или до вызова одной из функций, упомянутых выше.</p><p>И наоборот, диапазон может быть десуммирован с помощью функции brin_desummarize_range(regclass, bigint), которая полезна, когда индексный кортеж больше не является хорошим представлением, поскольку существующие значения изменились. Подробности см. в разделе 9.28.8.</p><p>Основной дистрибутив PostgreSQL включает классы операторов BRIN, показанные в таблице 64.4.</p><p>Классы операторов minmax хранят минимальные и максимальные значения, появляющиеся в индексированном столбце в пределах диапазона. Классы операторов include хранят значение, которое включает значения в индексированном столбце в пределах диапазона. Классы операторов bloom создают фильтр Bloom для всех значений в диапазоне. Классы операторов minmax-multi хранят несколько минимальных и максимальных значений, представляющих значения, появляющиеся в индексированном столбце в пределах диапазона.</p><p>Таблица 64.4. Встроенные классы операторов BRIN</p><p>Некоторые из встроенных классов операторов позволяют указывать параметры, влияющие на поведение класса операторов. Каждый класс операторов имеет свой собственный набор разрешенных параметров. Только классы операторов bloom и minmax-multi позволяют указывать параметры:</p><p>Классы операторов Блума принимают следующие параметры:</p><p>Определяет предполагаемое количество отдельных ненулевых значений в диапазоне блоков, используемых индексами Блума BRIN для определения размера фильтра Блума. Он ведет себя аналогично параметру n_distinct для ALTER TABLE. При установке положительного значения предполагается, что каждый диапазон блоков содержит это количество отдельных ненулевых значений. При установке отрицательного значения, которое должно быть больше или равно -1, предполагается, что количество отдельных ненулевых значений растет линейно с максимально возможным количеством кортежей в диапазоне блоков (около 290 строк на блок). Значение по умолчанию равно -0,1, а минимальное количество отдельных ненулевых значений равно 16.</p><p>Определяет желаемый уровень ложных срабатываний, используемый индексами Блума BRIN для определения размера фильтра Блума. Значения должны быть в диапазоне от 0,0001 до 0,25. Значение по умолчанию — 0,01, что составляет 1% уровня ложных срабатываний.</p><p>Классы операторов minmax-multi принимают следующие параметры:</p><p>Определяет максимальное количество значений, хранящихся в индексах BRIN minmax для суммирования диапазона блоков. Каждое значение может представлять либо точку, либо границу интервала. Значения должны быть в диапазоне от 8 до 256, а значение по умолчанию — 32.</p><p>Интерфейс BRIN имеет высокий уровень абстракции, требуя от реализатора метода доступа только реализации семантики типа данных, к которому осуществляется доступ. Сам слой BRIN заботится о параллелизме, ведении журнала и поиске в структуре индекса.</p><p>Все, что нужно для того, чтобы метод доступа BRIN заработал, — это реализовать несколько пользовательских методов, которые определяют поведение сводных значений, хранящихся в индексе, и то, как они взаимодействуют с ключами сканирования. Короче говоря, BRIN сочетает расширяемость с универсальностью, повторное использование кода и чистый интерфейс.</p><p>Класс оператора для BRIN должен предоставлять четыре метода:</p><p>Возвращает внутреннюю информацию о сводных данных индексированных столбцов. Возвращаемое значение должно указывать на palloc'd BrinOpcInfo, который имеет следующее определение:</p><p>Brinopcinfo.oi_opaque может использоваться подпрограммами класса оператора для передачи информации между функциями поддержки во время индексного сканирования.</p><p>Возвращает, соответствуют ли все записи ScanKey заданным индексированным значениям для диапазона. Номер атрибута для использования передается как часть ключа сканирования. Несколько ключей сканирования для одного и того же атрибута могут быть переданы одновременно; количество записей определяется параметром nkeys.</p><p>Возвращает, соответствует ли сканирование с данными индексированными значениями для диапазона.</p><p>При наличии индексного кортежа и индексированного значения изменяет указанный атрибут кортежа так, чтобы он дополнительно представлял новое значение. Если в кортеж были внесены какие-либо изменения, возвращается значение true.</p><p>Объединяет два кортежа индексов. При наличии двух кортежей индексов изменяет указанный атрибут первого из них так, чтобы он представлял оба кортежа. Второй кортеж не изменяется.</p><p>Класс оператора для BRIN может опционально указывать следующий метод:</p><p>Определяет набор видимых пользователю параметров, которые управляют поведением класса оператора.</p><p>Функция «Параметры» передается по указанию на структуру локального_релопта, которая должна быть заполнена набором специфических параметров класса оператора.</p><p>Поскольку как извлечение ключа из индексированных значений, так и представление ключа в BRIN являются гибкими, они могут зависеть от указанных пользователем параметров.</p><p>Основной дистрибутив включает поддержку четырех типов классов операторов: minmax, minmax-multi, include и bloom. Определения классов операторов, использующие их, поставляются для типов данных ядра по мере необходимости. Дополнительные классы операторов могут быть определены пользователем для других типов данных с использованием эквивалентных определений без необходимости писать какой-либо исходный код; достаточно объявить соответствующие записи каталога. Обратите внимание, что предположения о семантике стратегий операторов встроены в исходный код функций поддержки.</p><p>Классы операторов, реализующие совершенно другую семантику, также возможны, при условии, что написаны реализации четырех основных функций поддержки, описанных выше. Обратите внимание, что обратная совместимость между основными выпусками не гарантируется: например, в более поздних выпусках могут потребоваться дополнительные функции поддержки.</p><p>Чтобы написать класс операторов для типа данных, который реализует полностью упорядоченный набор, можно использовать функции поддержки minmax вместе с соответствующими операторами, как показано в таблице 64.5. Все члены класса операторов (функции и операторы) являются обязательными.</p><p>Таблица 64.5. Функции и опорные числа для классов операторов Minmax</p><p>Чтобы написать класс операторов для сложного типа данных, значения которого включены в другой тип, можно использовать функции поддержки включения вместе с соответствующими операторами, как показано в таблице 64.6. Для этого требуется только одна дополнительная функция, которая может быть написана на любом языке. Для дополнительной функциональности можно определить больше функций. Все операторы являются необязательными. Для некоторых операторов требуются другие операторы, как показано в виде зависимостей в таблице.</p><p>Таблица 64.6. Функции и опорные числа для классов операторов включения</p><p>Номера функций поддержки от 1 до 10 зарезервированы для внутренних функций BRIN, поэтому функции уровня SQL начинаются с номера 11. Функция поддержки номер 11 является основной функцией, необходимой для построения индекса. Она должна принимать два аргумента с тем же типом данных, что и класс оператора, и возвращать их объединение. Класс оператора включения может хранить значения объединения с разными типами данных, если он определен с параметром STORAGE. Возвращаемое значение функции объединения должно соответствовать типу данных STORAGE.</p><p>Функции поддержки 12 и 14 предусмотрены для поддержки нерегулярностей встроенных типов данных. Функция 12 используется для поддержки сетевых адресов из разных семейств, которые не могут быть объединены. Функция 14 используется для поддержки пустых диапазонов. Функция 13 является необязательной, но рекомендуемой, она позволяет проверять новое значение перед его передачей в функцию объединения. Поскольку фреймворк BRIN может сокращать некоторые операции, когда объединение не изменяется, использование этой функции может улучшить производительность индекса.</p><p>Чтобы написать класс операторов для типа данных, который реализует только оператор равенства и поддерживает хеширование, можно использовать процедуры поддержки Блума вместе с соответствующими операторами, как показано в Таблице 64.7. Все члены класса операторов (процедуры и операторы) являются обязательными.</p><p>Таблица 64.7. Процедуры и опорные числа для классов операторов Блума</p><p>Номера вспомогательных процедур 1-10 зарезервированы для внутренних функций BRIN, поэтому функции уровня SQL начинаются с номера 11. Вспомогательная функция номер 11 — это основная функция, необходимая для построения индекса. Она должна принимать один аргумент с тем же типом данных, что и класс оператора, и возвращать хэш значения.</p><p>Класс операторов minmax-multi также предназначен для типов данных, реализующих полностью упорядоченный набор, и может рассматриваться как простое расширение класса операторов minmax. В то время как класс операторов minmax суммирует значения из каждого диапазона блоков в один непрерывный интервал, minmax-multi допускает суммирование в несколько меньших интервалов для улучшения обработки выбросов. Можно использовать процедуры поддержки minmax-multi вместе с соответствующими операторами, как показано в таблице 64.8. Все члены класса операторов (процедуры и операторы) являются обязательными.</p><p>Таблица 64.8. Процедуры и опорные числа для классов операторов minmax-multi</p><p>Оба класса операторов minmax и include поддерживают операторы перекрестных типов данных, хотя с ними зависимости становятся более сложными. Класс операторов minmax требует определения полного набора операторов с обоими аргументами, имеющими одинаковый тип данных. Он позволяет поддерживать дополнительные типы данных, определяя дополнительные наборы операторов. Стратегии операторов класса операторов включения зависят от другой стратегии оператора, как показано в таблице 64.6, или той же стратегии оператора, что и они сами. Они требуют, чтобы оператор зависимости был определен с типом данных STORAGE в качестве левого аргумента, а другой поддерживаемый тип данных был правым аргументом поддерживаемого оператора. См. float4_minmax_ops в качестве примера minmax и box_inclusion_ops в качестве примера включения.</p>