<h2>64.4. GIN Indexes #</h2>
<p>GIN означает Generalized Inverted Index (Обобщенный инвертированный индекс). GIN предназначен для обработки случаев, когда индексируемые элементы являются составными значениями, а запросы, которые должны обрабатываться индексом, должны искать значения элементов, которые появляются в составных элементах. Например, элементы могут быть документами, а запросы могут быть поисками документов, содержащих определенные слова.</p><p>Мы используем слово item для обозначения составного значения, которое должно быть проиндексировано, а слово key для обозначения значения элемента. GIN всегда хранит и ищет ключи, а не значения элементов как таковые.</p><p>Индекс GIN хранит набор пар (ключ, список размещения), где список размещения — это набор идентификаторов строк, в которых встречается ключ. Один и тот же идентификатор строки может встречаться в нескольких списках размещения, поскольку элемент может содержать более одного ключа. Каждое значение ключа хранится только один раз, поэтому индекс GIN очень компактен для случаев, когда один и тот же ключ встречается много раз.</p><p>GIN обобщен в том смысле, что код метода доступа GIN не должен знать конкретные операции, которые он ускоряет. Вместо этого он использует пользовательские стратегии, определенные для определенных типов данных. Стратегия определяет, как ключи извлекаются из индексированных элементов и условий запроса, и как определить, удовлетворяет ли строка, содержащая некоторые из ключевых значений в запросе, на самом деле запросу.</p><p>Одним из преимуществ GIN является то, что он позволяет разрабатывать пользовательские типы данных с соответствующими методами доступа эксперту в области типа данных, а не эксперту по базам данных. Это во многом то же самое преимущество, что и использование GiST.</p><p>Реализацию GIN в PostgreSQL в основном поддерживают Теодор Сигаев и Олег Бартунов. Более подробная информация о GIN доступна на их сайте.</p><p>Основной дистрибутив PostgreSQL включает классы операторов GIN, показанные в таблице 64.3. (Некоторые из дополнительных модулей, описанных в приложении F, предоставляют дополнительные классы операторов GIN.)</p><p>Таблица 64.3. Встроенные классы операторов GIN</p><p>Из двух классов операторов для типа jsonb, jsonb_ops является классом по умолчанию. jsonb_path_ops поддерживает меньше операторов, но обеспечивает лучшую производительность для этих операторов. Подробности см. в разделе 8.14.4.</p><p>Интерфейс GIN имеет высокий уровень абстракции, требуя от реализатора метода доступа только реализации семантики типа данных, к которому осуществляется доступ. Сам уровень GIN заботится о параллелизме, ведении журнала и поиске в древовидной структуре.</p><p>Все, что нужно для того, чтобы метод доступа GIN заработал, — это реализовать несколько пользовательских методов, которые определяют поведение ключей в дереве и отношения между ключами, индексированными элементами и индексируемыми запросами. Короче говоря, GIN сочетает расширяемость с универсальностью, повторное использование кода и чистый интерфейс.</p><p>Класс оператора для GIN должен предоставлять два метода:</p><p>Возвращает palloc'd массив ключей, заданных элементом для индексации. Количество возвращенных ключей должно быть сохранено в *nkeys. Если какой-либо из ключей может быть null, также palloc массив из *nkeys bool полей, сохраните его адрес в *nullFlags и установите эти null флаги по мере необходимости. *nullFlags можно оставить NULL (его начальное значение), если все ключи не равны null. Возвращаемое значение может быть NULL, если элемент не содержит ключей.</p><p>Возвращает palloc'd массив ключей, заданных значением для запроса; то есть query — это значение в правой части индексируемого оператора, левая часть которого — индексированный столбец. n — это номер стратегии оператора в классе операторов (см. раздел 36.16.2). Часто extractQuery необходимо будет обратиться к n, чтобы определить тип данных запроса и метод, который он должен использовать для извлечения значений ключей. Количество возвращаемых ключей должно быть сохранено в *nkeys. Если какой-либо из ключей может быть пустым, также palloc массив из *nkeys полей bool, сохраните его адрес в *nullFlags и установите эти флаги null по мере необходимости. *nullFlags можно оставить равным NULL (его начальное значение), если все ключи не равны NULL. Возвращаемое значение может быть равно NULL, если запрос не содержит ключей.</p><p>searchMode — это выходной аргумент, позволяющий extractQuery указывать сведения о том, как будет выполняться поиск. Если *searchMode установлен в GIN_SEARCH_MODE_DEFAULT (это значение, которому он инициализируется перед вызовом), то только элементы, соответствующие хотя бы одному из возвращенных ключей, считаются кандидатами на совпадения. Если *searchMode установлен в GIN_SEARCH_MODE_INCLUDE_EMPTY, то в дополнение к элементам, содержащим хотя бы один совпадающий ключ, элементы, не содержащие ключей вообще, считаются кандидатами на совпадения. (Этот режим полезен, например, для реализации операторов is-subset-of.) Если *searchMode установлен в GIN_SEARCH_MODE_ALL, то все ненулевые элементы в индексе считаются кандидатами на совпадения, независимо от того, соответствуют ли они какому-либо из возвращенных ключей или нет. (Этот режим намного медленнее двух других вариантов, поскольку он требует сканирования по сути всего индекса, но может потребоваться правильная реализация крайних случаев. Оператор, которому в большинстве случаев требуется этот режим, вероятно, не является хорошим кандидатом для класса операторов GIN.) Символы, используемые для установки этого режима, определены в access/gin.h.</p><p>pmatch — это выходной аргумент для использования, когда поддерживается частичное совпадение. Чтобы использовать его, extractQuery должен выделить массив *nkeys bool и сохранить его адрес в *pmatch. Каждый элемент массива должен быть установлен в true, если соответствующий ключ требует частичного совпадения, и в false, если нет. Если *pmatch установлен в NULL, то GIN предполагает, что частичное совпадение не требуется. Переменная инициализируется значением NULL перед вызовом, поэтому этот аргумент может просто игнорироваться классами операторов, которые не поддерживают частичное совпадение.</p><p>extra_data — это выходной аргумент, который позволяет extractQuery передавать дополнительные данные в методы conform и comparePartial. Чтобы использовать его, extractQuery должен выделить массив указателей *nkeys и сохранить его адрес в *extra_data, а затем сохранить все, что он хочет, в отдельных указателях. Переменная инициализируется значением NULL перед вызовом, поэтому этот аргумент может просто игнорироваться классами операторов, которым не требуются дополнительные данные. Если задано *extra_data, весь массив передается в метод conform, а соответствующий элемент — в метод comparePartial.</p><p>Класс оператора также должен предоставлять функцию для проверки соответствия индексированного элемента запросу. Он поставляется в двух вариантах: булева согласованная функция и тернарная функция triConsistent. triConsistent охватывает функциональность обеих, поэтому предоставления только triConsistent достаточно. Однако, если булев вариант значительно дешевле для вычисления, может быть выгодно предоставить оба. Если предоставляется только булев вариант, некоторые оптимизации, которые зависят от опровержения элементов индекса перед извлечением всех ключей, отключаются.</p><p>Возвращает true, если индексированный элемент удовлетворяет оператору запроса со стратегией номер n (или может удовлетворять ему, если возвращается указание повторной проверки). Эта функция не имеет прямого доступа к значению индексированного элемента, поскольку GIN не хранит элементы явно. Вместо этого доступны знания о том, какие значения ключей, извлеченные из запроса, появляются в данном индексированном элементе. Массив проверки имеет длину nkeys, что совпадает с количеством ключей, ранее возвращенных extractQuery для этого элемента данных запроса. Каждый элемент массива проверки имеет значение true, если индексированный элемент содержит соответствующий ключ запроса, т. е. если (check[i] == true) i-й ключ массива результатов extractQuery присутствует в индексированном элементе. Исходный элемент данных запроса передается в случае, если методу conformance необходимо обратиться к нему, как и массивы queryKeys[] и nullFlags[], ранее возвращенные extractQuery. extra_data — это массив дополнительных данных, возвращаемый extractQuery, или NULL, если нет.</p><p>Когда extractQuery возвращает нулевой ключ в queryKeys[], соответствующий элемент check[] имеет значение true, если индексированный элемент содержит нулевой ключ; то есть семантика check[] похожа на IS NOT DISTINCT FROM. Консистентная функция может проверить соответствующий элемент nullFlags[], если ей нужно определить разницу между обычным соответствием значения и нулевым соответствием.</p><p>При успешном выполнении *recheck следует установить в значение true, если кортеж кучи необходимо перепроверить с помощью оператора запроса, или в значение false, если проверка индекса точна. То есть возвращаемое значение false гарантирует, что кортеж кучи не соответствует запросу; возвращаемое значение true с *recheck, установленным в значение false, гарантирует, что кортеж кучи соответствует запросу; а возвращаемое значение true с *recheck, установленным в значение true, означает, что кортеж кучи может соответствовать запросу, поэтому его необходимо извлечь и перепроверить, оценив оператор запроса напрямую по изначально индексированному элементу.</p><p>triConsistent похож на conform, но вместо булевых значений в проверочном векторе есть три возможных значения для каждого ключа: GIN_TRUE, GIN_FALSE и GIN_MAYBE. GIN_FALSE и GIN_TRUE имеют то же значение, что и обычные булевые значения, в то время как GIN_MAYBE означает, что наличие этого ключа неизвестно. Когда присутствуют значения GIN_MAYBE, функция должна возвращать GIN_TRUE только в том случае, если элемент определенно совпадает, независимо от того, содержит ли элемент индекса соответствующие ключи запроса. Аналогично, функция должна возвращать GIN_FALSE только в том случае, если элемент определенно не совпадает, независимо от того, содержит ли он ключи GIN_MAYBE. Если результат зависит от записей GIN_MAYBE, т. е. совпадение не может быть подтверждено или опровергнуто на основе известных ключей запроса, функция должна возвращать GIN_MAYBE.</p><p>Если в проверочном векторе нет значений GIN_MAYBE, возвращаемое значение GIN_MAYBE эквивалентно установке флага повторной проверки в логической согласованной функции.</p><p>Кроме того, GIN должен иметь способ сортировки ключевых значений, хранящихся в индексе. Класс оператора может определить порядок сортировки, указав метод сравнения:</p><p>Сравнивает два ключа (не индексированные элементы!) и возвращает целое число меньше нуля, ноль или больше нуля, указывая, является ли первый ключ меньше, равен или больше второго. Пустые ключи никогда не передаются в эту функцию.</p><p>В качестве альтернативы, если класс операторов не предоставляет метод сравнения, GIN будет искать класс операторов btree по умолчанию для типа данных ключа индекса и использовать его функцию сравнения. Рекомендуется указывать функцию сравнения в классе операторов GIN, который предназначен только для одного типа данных, так как поиск класса операторов btree занимает несколько циклов. Однако полиморфные классы операторов GIN (такие как array_ops) обычно не могут указывать одну функцию сравнения.</p><p>Класс оператора для GIN может опционально предоставлять следующие методы:</p><p>Сравнение ключа запроса с частичным совпадением с ключом индекса. Возвращает целое число, знак которого указывает на результат: меньше нуля означает, что ключ индекса не соответствует запросу, но сканирование индекса должно продолжаться; ноль означает, что ключ индекса соответствует запросу; больше нуля означает, что сканирование индекса должно быть остановлено, поскольку больше совпадений невозможны. Предоставляется номер стратегии n оператора, сгенерировавшего запрос с частичным совпадением, на случай, если его семантика необходима для определения того, когда следует завершить сканирование. Кроме того, extra_data является соответствующим элементом массива дополнительных данных, созданного extractQuery, или NULL, если его нет. Пустые ключи никогда не передаются в эту функцию.</p><p>Определяет набор видимых пользователю параметров, которые управляют поведением класса оператора.</p><p>Функция options передает указатель на структуру local_relopts, которую необходимо заполнить набором опций, специфичных для класса операторов. Доступ к опциям можно получить из других функций поддержки с помощью макросов PG_HAS_OPCLASS_OPTIONS() и PG_GET_OPCLASS_OPTIONS().</p><p>Поскольку как извлечение ключа из индексированных значений, так и представление ключа в GIN являются гибкими, они могут зависеть от указанных пользователем параметров.</p><p>Для поддержки запросов «частичного соответствия» класс оператора должен предоставлять метод comparePartial, а его метод extractQuery должен устанавливать параметр pmatch при обнаружении запроса частичного соответствия. Подробности см. в разделе 64.4.4.2.</p><p>Фактические типы данных различных значений Datum, упомянутых выше, различаются в зависимости от класса оператора. Значения элементов, передаваемые в extractValue, всегда имеют тип ввода класса оператора, а все ключевые значения должны иметь тип STORAGE класса. Тип аргумента запроса, передаваемого в extractQuery, consist и triConsistent, — это тот, который является правым типом ввода оператора-члена класса, идентифицированного номером стратегии. Он не обязательно должен совпадать с индексированным типом, если из него можно извлечь ключевые значения правильного типа. Однако рекомендуется, чтобы объявления SQL этих трех функций поддержки использовали индексированный тип данных opclass для аргумента запроса, даже если фактический тип может быть другим в зависимости от оператора.</p><p>Внутри индекс GIN содержит индекс B-дерева, построенный по ключам, где каждый ключ является элементом одного или нескольких индексированных элементов (например, членом массива) и где каждый кортеж на странице листа содержит либо указатель на B-дерево указателей кучи («дерево размещения»), либо простой список указателей кучи («список размещения»), когда список достаточно мал, чтобы поместиться в один индексный кортеж вместе со значением ключа. Рисунок 64.1 иллюстрирует эти компоненты индекса GIN.</p><p>Начиная с PostgreSQL 9.1, в индекс могут быть включены нулевые значения ключей. Кроме того, пустые значения-заполнители включаются в индекс для индексированных элементов, которые являются нулевыми или не содержат ключей согласно extractValue. Это позволяет выполнять поиск, который должен находить пустые элементы.</p><p>Многостолбцовые индексы GIN реализуются путем построения одного B-дерева по составным значениям (номер столбца, ключевое значение). Ключевое значение для разных столбцов может быть разного типа.</p><p>Рисунок 64.1. Внутреннее устройство GIN</p><p>Обновление индекса GIN, как правило, происходит медленно из-за внутренней природы инвертированных индексов: вставка или обновление одной строки кучи может вызвать множество вставок в индекс (по одной для каждого ключа, извлеченного из индексированного элемента). GIN способен отложить большую часть этой работы, вставляя новые кортежи во временный, несортированный список ожидающих записей. Когда таблица очищается или автоматически анализируется, или когда вызывается функция gin_clean_pending_list, или если ожидающий список становится больше gin_pending_list_limit, записи перемещаются в основную структуру данных GIN с использованием тех же методов массовой вставки, которые использовались при первоначальном создании индекса. Это значительно повышает скорость обновления индекса GIN, даже учитывая дополнительные накладные расходы на очистку. Более того, накладные расходы могут быть выполнены фоновым процессом вместо обработки запроса на переднем плане.</p><p>Главным недостатком этого подхода является то, что поиск должен сканировать список ожидающих записей в дополнение к поиску в обычном индексе, и поэтому большой список ожидающих записей значительно замедлит поиск. Другим недостатком является то, что, хотя большинство обновлений быстрые, обновление, которое приводит к тому, что ожидающий список становится «слишком большим», повлечет за собой немедленный цикл очистки и, таким образом, будет намного медленнее, чем другие обновления. Правильное использование автоочистки может минимизировать обе эти проблемы.</p><p>Если согласованное время отклика важнее скорости обновления, использование ожидающих записей можно отключить, отключив параметр хранения fastupdate для индекса GIN. Подробности см. в разделе CREATE INDEX.</p><p>GIN может поддерживать запросы «частичного соответствия», в которых запрос не определяет точное совпадение для одного или нескольких ключей, но возможные совпадения попадают в разумно узкий диапазон значений ключей (в пределах порядка сортировки ключей, определенного методом поддержки сравнения). Метод extractQuery, вместо возврата значения ключа для точного сопоставления, возвращает значение ключа, которое является нижней границей диапазона для поиска, и устанавливает флаг pmatch в значение true. Затем диапазон ключей сканируется с помощью метода comparePartial. comparePartial должен возвращать ноль для совпадающего индексного ключа, меньше нуля для несовпадения, которое все еще находится в диапазоне для поиска, или больше нуля, если индексный ключ выходит за пределы диапазона, который может совпасть.</p><p>Вставка в индекс GIN может быть медленной из-за вероятности вставки многих ключей для каждого элемента. Поэтому для массовых вставок в таблицу рекомендуется удалить индекс GIN и создать его заново после завершения массовой вставки.</p><p>Когда fastupdate включен для GIN (см. раздел 64.4.4.1 для получения подробной информации), штраф меньше, чем когда он не включен. Но для очень больших обновлений все равно может быть лучше удалить и пересоздать индекс.</p><p>Время построения индекса GIN очень чувствительно к настройке maintenance_work_mem; не стоит экономить на рабочей памяти при создании индекса.</p><p>Во время серии вставок в существующий индекс GIN, в котором включен fastupdate, система будет очищать список ожидающих записей всякий раз, когда список становится больше gin_pending_list_limit. Чтобы избежать колебаний в наблюдаемом времени отклика, желательно, чтобы очистка ожидающих записей происходила в фоновом режиме (т. е. с помощью автоочистки). Операции очистки переднего плана можно избежать, увеличив gin_pending_list_limit или сделав автоочистку более агрессивной. Однако увеличение порога операции очистки означает, что если очистка переднего плана действительно произойдет, она займет еще больше времени.</p><p>gin_pending_list_limit можно переопределить для отдельных индексов GIN, изменив параметры хранения, что позволяет каждому индексу GIN иметь свой собственный порог очистки. Например, можно увеличить порог только для индекса GIN, который может обновляться интенсивно, и уменьшить его в противном случае.</p><p>Основной целью разработки индексов GIN было создание поддержки высокомасштабируемого полнотекстового поиска в PostgreSQL, и часто возникают ситуации, когда полнотекстовый поиск возвращает очень большой набор результатов. Более того, это часто происходит, когда запрос содержит очень частые слова, так что большой набор результатов даже бесполезен. Поскольку чтение множества кортежей с диска и их сортировка могут занять много времени, это неприемлемо для производства. (Обратите внимание, что сам поиск по индексу очень быстрый.)</p><p>Для облегчения контролируемого выполнения таких запросов GIN имеет настраиваемый мягкий верхний предел количества возвращаемых строк: параметр конфигурации gin_fuzzy_search_limit. По умолчанию он установлен на 0 (что означает отсутствие предела). Если установлен ненулевой предел, то возвращаемый набор является подмножеством всего набора результатов, выбранным случайным образом.</p><p>«Мягкий» означает, что фактическое количество возвращаемых результатов может несколько отличаться от указанного предела в зависимости от запроса и качества генератора случайных чисел системы.</p><p>По опыту, значения в тысячи (например, 5000–20000) работают хорошо.</p><p>GIN предполагает, что индексируемые операторы являются строгими. Это означает, что extractValue вообще не будет вызываться для нулевого значения элемента (вместо этого автоматически создается запись индекса-заполнителя), а extractQuery также не будет вызываться для нулевого значения запроса (вместо этого запрос предполагается невыполнимым). Однако следует отметить, что поддерживаются нулевые значения ключа, содержащиеся в ненулевом составном элементе или значении запроса.</p><p>Основной дистрибутив PostgreSQL включает классы операторов GIN, ранее показанные в Таблице 64.3. Следующие модули contrib также содержат классы операторов GIN:</p><p>Эквивалентная функциональность B-дерева для нескольких типов данных</p><p>Модуль для хранения пар (ключ, значение)</p><p>Расширенная поддержка int[]</p><p>Сходство текста с использованием сопоставления триграмм</p>