<h2>64.1. B-Tree Indexes #</h2>
<p>PostgreSQL включает реализацию стандартной структуры индекса btree (многоканальное сбалансированное дерево). Любой тип данных, который может быть отсортирован в четко определенном линейном порядке, может быть проиндексирован индексом btree. Единственное ограничение заключается в том, что запись индекса не может превышать приблизительно одну треть страницы (после сжатия TOAST, если применимо).</p><p>Поскольку каждый класс операторов btree накладывает порядок сортировки на свой тип данных, классы операторов btree (или, на самом деле, семейства операторов) стали использоваться в качестве общего представления и понимания семантики сортировки PostgreSQL. Поэтому они приобрели некоторые функции, выходящие за рамки того, что было бы необходимо только для поддержки индексов btree, и части системы, которые довольно далеки от AM btree, используют их.</p><p>Как показано в таблице 36.3, класс операторов btree должен предоставлять пять операторов сравнения: <, <=, =, >= и >. Можно было бы ожидать, что <> также должен быть частью класса операторов, но это не так, поскольку почти никогда не будет полезно использовать предложение <> WHERE в поиске по индексу. (Для некоторых целей планировщик рассматривает <> как связанный с классом операторов btree; но он находит этот оператор через отрицательную ссылку оператора =, а не из pg_amop.)</p><p>Когда несколько типов данных разделяют почти идентичную семантику сортировки, их классы операторов могут быть сгруппированы в семейство операторов. Это выгодно, поскольку позволяет планировщику делать выводы о сравнениях между типами. Каждый класс операторов в семействе должен содержать операторы одного типа (и связанные с ними функции поддержки) для своего типа входных данных, в то время как операторы сравнения между типами и функции поддержки «свободны» в семействе. Рекомендуется, чтобы полный набор операторов между типами был включен в семейство, таким образом гарантируя, что планировщик может представлять любые условия сравнения, которые он выводит из транзитивности.</p><p>Существуют некоторые основные предположения, которым должно удовлетворять семейство операторов B-Tree:</p><p>Оператор = должен быть отношением эквивалентности, то есть для всех ненулевых значений A, B, C типа данных:</p><p>A = A верно (рефлексивный закон)</p><p>если A = B, то B = A (симметричный закон)</p><p>если A = B и B = C, то A = C (транзитивный закон)</p><p>Оператор < должен быть строгим упорядочивающим отношением; то есть для всех ненулевых значений A, B, C:</p><p>A < A ложно (иррефлексивный закон)</p><p>если A < B и B < C, то A < C (транзитивный закон)</p><p>Более того, упорядочение является полным, то есть для всех ненулевых значений A, B:</p><p>ровно одно из утверждений A < B, A = B и B < A верно (закон трихотомии)</p><p>(Конечно, закон трихотомии оправдывает определение функции поддержки сравнения.)</p><p>Остальные три оператора очевидным образом определяются в терминах = и < и должны действовать согласованно с ними.</p><p>Для семейства операторов, поддерживающего несколько типов данных, вышеуказанные законы должны выполняться, когда A, B, C берутся из любых типов данных в семействе. Транзитивные законы сложнее всего обеспечить, так как в ситуациях с перекрестными типами они представляют утверждения о том, что поведение двух или трех различных операторов является согласованным. Например, не будет работать помещение float8 и numeric в одно и то же семейство операторов, по крайней мере, не с текущей семантикой, согласно которой числовые значения преобразуются в float8 для сравнения с float8. Из-за ограниченной точности float8 это означает, что существуют различные числовые значения, которые будут сравниваться равными одному и тому же значению float8, и, таким образом, транзитивный закон не будет работать.</p><p>Еще одним требованием к семейству с несколькими типами данных является то, что любые неявные или двоичные приведения, определенные между типами данных, включенными в семейство операторов, не должны изменять связанный порядок сортировки.</p><p>Должно быть достаточно ясно, почему индекс btree требует, чтобы эти законы соблюдались в пределах одного типа данных: без них нет порядка, с которым можно было бы упорядочить ключи. Кроме того, поиск индекса с использованием ключа сравнения другого типа данных требует, чтобы сравнения вели себя разумно по двум типам данных. Расширения до трех или более типов данных в пределах семейства не являются строго обязательными для самого механизма индекса btree, но планировщик полагается на них в целях оптимизации.</p><p>Как показано в Таблице 36.9, btree определяет одну обязательную и четыре необязательные функции поддержки. Пять определяемых пользователем методов:</p><p>Для каждой комбинации типов данных, для которых семейство операторов btree предоставляет операторы сравнения, оно должно предоставлять функцию поддержки сравнения, зарегистрированную в pg_amproc с функцией поддержки номер 1 и amproclefttype/amprocrighttype, равными левому и правому типам данных для сравнения (т. е. тем же типам данных, с которыми зарегистрированы соответствующие операторы в pg_amop). Функция сравнения должна принимать два непустых значения A и B и возвращать значение int32, которое < 0, 0 или > 0, когда A < B, A = B или A > B соответственно. Нулевой результат не допускается: все значения типа данных должны быть сравнимы. См. src/backend/access/nbtree/nbtcompare.c для примеров.</p><p>Если сравниваемые значения имеют тип данных, поддающийся сопоставлению, соответствующий идентификатор объекта сопоставления будет передан в функцию поддержки сравнения с использованием стандартного механизма PG_GET_COLLATION().</p><p>При желании семейство операторов btree может предоставлять функцию(и) поддержки сортировки, зарегистрированную под номером функции поддержки 2. Эти функции позволяют реализовывать сравнения для целей сортировки более эффективным способом, чем наивный вызов функции поддержки сравнения. API, задействованные в этом, определены в src/include/utils/sortsupport.h.</p><p>При желании семейство операторов btree может предоставлять функцию(и) поддержки in_range, зарегистрированную под номером функции поддержки 3. Они не используются во время операций индекса btree; вместо этого они расширяют семантику семейства операторов, чтобы оно могло поддерживать предложения окна, содержащие типы рамок RANGE offset PRECEDING и RANGE offset FOLLOWING (см. раздел 4.2.8). По сути, дополнительная информация, предоставляемая, заключается в том, как добавлять или вычитать значение смещения способом, совместимым с порядком данных семейства.</p><p>Функция in_range должна иметь сигнатуру</p><p>val и base должны быть одного типа, который является одним из типов, поддерживаемых семейством операторов (т. е. типом, для которого он обеспечивает упорядочивание). Однако offset может быть другого типа, который может быть неподдерживаемым семейством. Примером является то, что встроенное семейство time_ops предоставляет функцию in_range, которая имеет смещение типа interval. Семейство может предоставлять функции in_range для любого из поддерживаемых им типов и одного или нескольких типов смещения. Каждая функция in_range должна быть введена в pg_amproc с amproclefttype, равным type1, и amprocrighttype, равным type2.</p><p>Основная семантика функции in_range зависит от двух параметров булевых флагов. Она должна добавлять или вычитать base и offset, а затем сравнивать val с результатом следующим образом:</p><p>если !sub и !less, вернуть значение >= (база + смещение)</p><p>если !sub и меньше, вернуть значение <= (база + смещение)</p><p>если sub и !less, вернуть значение >= (база - смещение)</p><p>если sub и меньше, вернуть значение <= (base - offset)</p><p>Перед этим функция должна проверить знак смещения: если он меньше нуля, выдать ошибку ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE (22013) с текстом ошибки типа «недопустимый предшествующий или последующий размер в оконной функции». (Этого требует стандарт SQL, хотя нестандартные семейства операторов, возможно, предпочтут проигнорировать это ограничение, поскольку в нем, по-видимому, мало семантической необходимости.) Это требование делегировано функции in_range, чтобы базовому коду не нужно было понимать, что означает «меньше нуля» для конкретного типа данных.</p><p>Дополнительное ожидание заключается в том, что функции in_range должны, если это практически осуществимо, избегать выдачи ошибки, если base + offset или base - offset приведет к переполнению. Правильный результат сравнения может быть определен, даже если это значение будет вне диапазона типа данных. Обратите внимание, что если тип данных включает такие концепции, как «бесконечность» или «NaN», может потребоваться дополнительная осторожность, чтобы гарантировать, что результаты in_range согласуются с нормальным порядком сортировки семейства операторов.</p><p>Результаты функции in_range должны соответствовать порядку сортировки, налагаемому семейством операторов. Если быть точным, то при любых фиксированных значениях offset и sub:</p><p>Если in_range с less = true является истинным для некоторых val1 и base, то он должен быть истинным для каждого val2 <= val1 с той же базой.</p><p>Если in_range с less = true является ложным для некоторых val1 и base, он должен быть ложным для каждого val2 >= val1 с тем же base.</p><p>Если in_range с less = true является истинным для некоторых val и base1, то он должен быть истинным для всех base2 >= base1 с тем же val.</p><p>Если in_range с less = true имеет значение false для некоторых val и base1, оно должно быть false для всех base2 <= base1 с тем же val.</p><p>Аналогичные утверждения с обратными условиями справедливы, когда меньше = ложь.</p><p>Если упорядочиваемый тип (type1) является сортируемым, соответствующий OID сортировки будет передан функции in_range с использованием стандартного механизма PG_GET_COLLATION().</p><p>Функции in_range не обязаны обрабатывать входные данные NULL и обычно помечаются как строгие.</p><p>При желании семейство операторов btree может предоставлять функции поддержки equalimage («равенство подразумевает равенство изображений»), зарегистрированные под номером функции поддержки 4. Эти функции позволяют основному коду определять, когда безопасно применять оптимизацию дедупликации btree. В настоящее время функции equalimage вызываются только при построении или перестроении индекса.</p><p>Функция equalimage должна иметь сигнатуру</p><p>Возвращаемое значение — статическая информация о классе операторов и сортировке. Возврат true указывает на то, что функция order для класса операторов гарантированно вернет только 0 («аргументы равны»), когда ее аргументы A и B также взаимозаменяемы без потери семантической информации. Отсутствие регистрации функции equalimage или возврат false указывает на то, что это условие не может считаться выполненным.</p><p>Аргумент opcintype — это pg_type.oid типа данных, который индексирует класс оператора. Это удобство, которое позволяет повторно использовать одну и ту же базовую функцию equalimage в классах операторов. Если opcintype — это тип данных, поддающийся сортировке, соответствующий идентификатор сопоставления будет передан функции equalimage с использованием стандартного механизма PG_GET_COLLATION().</p><p>Что касается класса оператора, возвращение true указывает на то, что дедупликация безопасна (или безопасна для сопоставления, OID которого был передан его функции equalimage). Однако основной код будет считать дедупликацию безопасной для индекса только тогда, когда каждый индексированный столбец использует класс оператора, который регистрирует функцию equalimage, и каждая функция фактически возвращает true при вызове.</p><p>Равенство изображений — это почти то же самое условие, что и простое побитовое равенство. Есть одно тонкое отличие: при индексации типа данных varlena дисковое представление двух равных изображений может не быть побитовым равным из-за непоследовательного применения сжатия TOAST на входе. Формально, когда функция equalimage класса операторов возвращает true, можно с уверенностью предположить, что функция datum_image_eq() C всегда будет согласовываться с функцией order класса операторов (при условии, что функциям equalimage и order передается один и тот же OID сортировки).</p><p>Основной код принципиально не способен вывести что-либо о статусе «равенство подразумевает равенство изображений» класса операторов в семействе с несколькими типами данных на основе сведений из других классов операторов в том же семействе. Кроме того, для семейства операторов не имеет смысла регистрировать функцию equalimage для кросс-типов, и попытка сделать это приведет к ошибке. Это связано с тем, что статус «равенство подразумевает равенство изображений» зависит не только от семантики сортировки/равенства, которая более или менее определена на уровне семейства операторов. В общем, семантику, которую реализует один конкретный тип данных, следует рассматривать отдельно.</p><p>Соглашение, которому следуют классы операторов, включенные в основной дистрибутив PostgreSQL, заключается в регистрации стандартной, универсальной функции equalimage. Большинство классов операторов регистрируют btequalimage(), что указывает на безусловную безопасность дедупликации. Классы операторов для типов данных, поддающихся сортировке, таких как текст, регистрируют btvarstrequalimage(), что указывает на безопасность дедупликации с детерминированными сортировками. Лучшая практика для сторонних расширений — регистрировать собственную пользовательскую функцию для сохранения контроля.</p><p>При желании семейство операторов B-дерева может предоставлять функции поддержки опций («опции, специфичные для класса операторов»), зарегистрированные под номером функции поддержки 5. Эти функции определяют набор видимых пользователю параметров, которые управляют поведением класса операторов.</p><p>Функция поддержки опций должна иметь сигнатуру</p><p>Функция передает указатель на структуру local_relopts, которую необходимо заполнить набором опций, специфичных для класса оператора. Доступ к опциям можно получить из других функций поддержки с помощью макросов PG_HAS_OPCLASS_OPTIONS() и PG_GET_OPCLASS_OPTIONS().</p><p>В настоящее время ни один класс операторов B-Tree не имеет функции поддержки опций. B-tree не допускает гибкого представления ключей, как GiST, SP-GiST, GIN и BRIN. Поэтому опции, вероятно, не имеют особого применения в текущем методе доступа к индексу B-tree. Тем не менее, эта функция поддержки была добавлена ​​в B-tree для единообразия и, вероятно, найдет применение в ходе дальнейшей эволюции B-tree в PostgreSQL.</p><p>В этом разделе рассматриваются детали реализации индекса B-Tree, которые могут быть полезны продвинутым пользователям. См. src/backend/access/nbtree/README в исходном дистрибутиве для гораздо более подробного, сфокусированного на внутренних компонентах описания реализации B-Tree.</p><p>Индексы PostgreSQL B-Tree представляют собой многоуровневые древовидные структуры, в которых каждый уровень дерева может использоваться как двусвязный список страниц. Одна метастраница хранится в фиксированном положении в начале первого сегментного файла индекса. Все остальные страницы являются либо конечными страницами, либо внутренними страницами. Конечные страницы — это страницы на самом нижнем уровне дерева. Все остальные уровни состоят из внутренних страниц. Каждая конечная страница содержит кортежи, указывающие на строки таблицы. Каждая внутренняя страница содержит кортежи, указывающие на следующий уровень ниже в дереве. Обычно более 99% всех страниц являются конечными страницами. Как внутренние страницы, так и конечные страницы используют стандартный формат страницы, описанный в разделе 65.6.</p><p>Новые листовые страницы добавляются в индекс B-Tree, когда существующая листовая страница не может вместить входящий кортеж. Операция разделения страницы освобождает место для элементов, которые изначально принадлежали переполненной странице, перемещая часть элементов на новую страницу. Разделения страниц также должны вставлять новую нисходящую ссылку на новую страницу в родительской странице, что может привести к разделению родительской страницы в свою очередь. Разделения страниц «каскадируются вверх» рекурсивным образом. Когда корневая страница наконец не может вместить новую нисходящую ссылку, происходит операция разделения корневой страницы. Это добавляет новый уровень в структуру дерева, создавая новую корневую страницу, которая находится на один уровень выше исходной корневой страницы.</p><p>Индексы B-Tree напрямую не знают, что в MVCC может быть несколько существующих версий одной и той же логической строки таблицы; для индекса каждый кортеж является независимым объектом, которому нужна своя собственная запись индекса. Кортежи «переключения версий» иногда могут накапливаться и отрицательно влиять на задержку запроса и пропускную способность. Обычно это происходит при интенсивной рабочей нагрузке UPDATE, когда большинство отдельных обновлений не могут применить оптимизацию HOT. Изменение значения только одного столбца, охватываемого одним индексом, во время UPDATE всегда требует нового набора кортежей индекса — по одному для каждого индекса в таблице. Обратите внимание, что это включает индексы, которые не были «логически изменены» UPDATE. Всем индексам потребуется последующий физический кортеж индекса, который указывает на последнюю версию в таблице. Каждый новый кортеж в каждом индексе, как правило, должен сосуществовать с исходным «обновленным» кортежем в течение короткого периода времени (обычно вскоре после фиксации транзакции UPDATE).</p><p>Индексы B-Tree постепенно удаляют кортежи индекса смены версий, выполняя проходы удаления индекса снизу вверх. Каждый проход удаления запускается в ответ на ожидаемое «разделение страницы смены версий». Это происходит только с индексами, которые логически не изменяются операторами UPDATE, где в противном случае произошло бы концентрированное накопление устаревших версий на определенных страницах. Разделение страницы обычно избегается, хотя возможно, что определенные эвристики на уровне реализации не смогут идентифицировать и удалить даже один мусорный кортеж индекса (в этом случае разделение страницы или проход дедупликации решают проблему входящего нового кортежа, не помещающегося на листовой странице). Наихудшее количество версий, которое должно пройти любое сканирование индекса (для любой отдельной логической строки), является важным фактором общей отзывчивости и пропускной способности системы. Проход удаления индекса снизу вверх нацелен на предполагаемые мусорные кортежи на одной листовой странице на основе качественных различий, включающих логические строки и версии. Это контрастирует с очисткой индекса «сверху вниз», выполняемой работниками автоочистки, которая запускается при превышении определенных количественных пороговых значений на уровне таблицы (см. раздел 24.1.6).</p><p>Не все операции удаления, выполняемые в индексах B-Tree, являются операциями удаления снизу вверх. Существует отдельная категория удаления кортежей индексов: простое удаление кортежей индексов. Это отложенная операция обслуживания, которая удаляет кортежи индексов, которые, как известно, можно безопасно удалить (те, у которых бит идентификатора элемента LP_DEAD уже установлен). Как и удаление индексов снизу вверх, простое удаление индексов происходит в точке, где ожидается разделение страницы, как способ избежать разделения.</p><p>Простое удаление является оппортунистическим в том смысле, что оно может иметь место только тогда, когда недавние сканирования индекса устанавливают биты LP_DEAD затронутых элементов попутно. До PostgreSQL 14 единственной категорией удаления B-Tree было простое удаление. Основные различия между ним и удалением снизу вверх заключаются в том, что только первое оппортунистически обусловлено активностью прохождения сканирования индекса, тогда как только последнее специально нацелено на смену версий из UPDATE, которые логически не изменяют индексированные столбцы.</p><p>Удаление индекса снизу вверх выполняет подавляющее большинство всех очисток мусорных кортежей индекса для определенных индексов с определенными рабочими нагрузками. Это ожидается с любым индексом B-Tree, который подвержен значительному изменению версий из-за ОБНОВЛЕНИЙ, которые редко или никогда логически не изменяют столбцы, которые охватывает индекс. Среднее и худшее число версий на логическую строку можно поддерживать на низком уровне исключительно за счет целевых инкрементных проходов удаления. Вполне возможно, что размер определенных индексов на диске никогда не увеличится даже на одну страницу/блок, несмотря на постоянное изменение версий из-за ОБНОВЛЕНИЙ. Даже в этом случае в конечном итоге потребуется исчерпывающая «чистка» с помощью операции VACUUM (обычно выполняемой в рабочем процессе автовакуума) как часть коллективной очистки таблицы и каждого из ее индексов.</p><p>В отличие от VACUUM, удаление индекса снизу вверх не дает никаких надежных гарантий относительно того, насколько старым может быть самый старый мусорный кортеж индекса. Ни одному индексу не может быть разрешено сохранять «плавающие мусорные» кортежи индекса, которые стали мертвыми до консервативной точки отсечения, общей для таблицы и всех ее индексов в совокупности. Этот фундаментальный инвариант уровня таблицы делает безопасным повторное использование TID таблиц. Вот как различные логические строки могут повторно использовать один и тот же TID таблицы с течением времени (хотя это никогда не может произойти с двумя логическими строками, чье время жизни охватывает один и тот же цикл VACUUM).</p><p>Дубликат — это кортеж листовой страницы (кортеж, указывающий на строку таблицы), где все индексированные ключевые столбцы имеют значения, которые соответствуют значениям столбцов из по крайней мере одного другого кортежа листовой страницы в том же индексе. Дублирующие кортежи довольно распространены на практике. Индексы B-Tree могут использовать специальное, эффективное по пространству представление для дубликатов, когда включена дополнительная техника: дедупликация.</p><p>Дедупликация работает путем периодического слияния групп дублирующихся кортежей вместе, образуя один кортеж списка постинга для каждой группы. Значение(я) ключа столбца появляются только один раз в этом представлении. Затем следует отсортированный массив TID, которые указывают на строки в таблице. Это значительно уменьшает размер хранилища индексов, где каждое значение (или каждая отдельная комбинация значений столбцов) появляется несколько раз в среднем. Задержка запросов может быть значительно уменьшена. Общая пропускная способность запросов может значительно увеличиться. Накладные расходы на рутинную очистку индекса также могут быть значительно уменьшены.</p><p>Дедупликация B-Tree столь же эффективна с «дубликатами», содержащими значение NULL, хотя значения NULL никогда не равны друг другу согласно члену = любого класса операторов B-Tree. Что касается любой части реализации, которая понимает структуру B-Tree на диске, NULL — это просто еще одно значение из области индексированных значений.</p><p>Процесс дедупликации происходит лениво, когда вставляется новый элемент, который не может поместиться на существующей конечной странице, но только когда удаление индексного кортежа не может освободить достаточно места для нового элемента (обычно удаление кратко рассматривается и затем пропускается). В отличие от кортежей списков размещения GIN, кортежи списков размещения B-Tree не нужно расширять каждый раз при вставке нового дубликата; они являются просто альтернативным физическим представлением исходного логического содержимого конечной страницы. Такая конструкция отдает приоритет стабильной производительности при смешанных рабочих нагрузках чтения-записи. Большинство клиентских приложений по крайней мере увидят умеренное улучшение производительности от использования дедупликации. Дедупликация включена по умолчанию.</p><p>CREATE INDEX и REINDEX применяют дедупликацию для создания кортежей списков постинга, хотя стратегия, которую они используют, немного отличается. Каждая группа дубликатов обычных кортежей, обнаруженных в отсортированном вводе, взятом из таблицы, объединяется в кортеж списка постинга перед добавлением к текущей ожидающей конечной странице. Отдельные кортежи списков постинга заполняются максимально возможным количеством TID. Конечные страницы записываются обычным способом, без отдельного прохода дедупликации. Эта стратегия хорошо подходит для CREATE INDEX и REINDEX, поскольку они являются одноразовыми пакетными операциями.</p><p>Рабочие нагрузки с большой нагрузкой на запись, которые не получают выгоды от дедупликации из-за малого количества или отсутствия дубликатов значений в индексах, повлекут за собой небольшое фиксированное снижение производительности (если только дедупликация явно не отключена). Параметр хранилища deduplicate_items можно использовать для отключения дедупликации в отдельных индексах. С рабочими нагрузками только для чтения никогда не происходит никакого снижения производительности, поскольку чтение кортежей списков постинга по крайней мере так же эффективно, как и чтение стандартного представления кортежа. Отключение дедупликации обычно не помогает.</p><p>Иногда уникальные индексы (а также уникальные ограничения) могут использовать дедупликацию. Это позволяет конечным страницам временно «поглощать» дополнительные дубликаты версий. Дедупликация в уникальных индексах усиливает удаление индекса снизу вверх, особенно в случаях, когда длительная транзакция удерживает снимок, который блокирует сборку мусора. Цель состоит в том, чтобы выиграть время для того, чтобы стратегия удаления индекса снизу вверх снова стала эффективной. Отсрочка разделения страниц до тех пор, пока одна длительная транзакция естественным образом не исчезнет, ​​может позволить проходу удаления снизу вверх быть успешным там, где более ранний проход удаления не удался.</p><p>Специальная эвристика применяется для определения того, следует ли выполнять проход дедупликации в уникальном индексе. Часто она может перейти сразу к разделению листовой страницы, избегая снижения производительности из-за траты циклов на бесполезные проходы дедупликации. Если вас беспокоят накладные расходы на дедупликацию, рассмотрите возможность выборочной установки deduplicate_items = off. Оставленная включенной дедупликация в уникальных индексах имеет мало недостатков.</p><p>Дедупликацию нельзя использовать во всех случаях из-за ограничений на уровне реализации. Безопасность дедупликации определяется при запуске CREATE INDEX или REINDEX.</p><p>Обратите внимание, что дедупликация считается небезопасной и не может использоваться в следующих случаях, когда имеются семантически значимые различия между одинаковыми данными:</p><p>text, varchar и char не могут использовать дедупликацию, когда используется недетерминированное сопоставление. Различия в регистре и акценте должны быть сохранены среди одинаковых данных.</p><p>Числовой не может использовать дедупликацию. Масштаб числового отображения должен быть сохранен среди равных дат.</p><p>jsonb не может использовать дедупликацию, поскольку класс операторов JSONB B-Tree использует внутренние числовые данные.</p><p>float4 и float8 не могут использовать дедупликацию. Эти типы имеют различные представления для -0 и 0, которые, тем не менее, считаются равными. Это различие должно быть сохранено.</p><p>Существует еще одно ограничение на уровне реализации, которое может быть снято в будущей версии PostgreSQL:</p><p>Типы контейнеров (такие как составные типы, массивы или диапазонные типы) не могут использовать дедупликацию.</p><p>Существует еще одно ограничение на уровне реализации, которое применяется независимо от класса оператора или используемого сопоставления:</p><p>Индексы INCLUDE никогда не могут использовать дедупликацию.</p>