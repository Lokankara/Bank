<h2>64.3. SP-GiST Indexes #</h2>
<p>SP-GiST — это аббревиатура для пространственно-разделенного GiST. SP-GiST поддерживает разделенные деревья поиска, которые облегчают разработку широкого спектра различных несбалансированных структур данных, таких как квадродеревья, деревья k-d и радиксные деревья (tries). Общей чертой этих структур является то, что они многократно делят пространство поиска на разделы, которые не обязательно должны быть одинакового размера. Поиски, которые хорошо соответствуют правилу разбиения, могут быть очень быстрыми.</p><p>Эти популярные структуры данных изначально были разработаны для использования в памяти. В основной памяти они обычно проектируются как набор динамически выделяемых узлов, связанных указателями. Это не подходит для прямого хранения на диске, поскольку эти цепочки указателей могут быть довольно длинными, что потребует слишком много обращений к диску. Напротив, дисковые структуры данных должны иметь высокую степень разветвления, чтобы минимизировать ввод-вывод. Задача, решаемая SP-GiST, заключается в сопоставлении узлов дерева поиска со страницами диска таким образом, чтобы поиску требовался доступ только к нескольким страницам диска, даже если он проходит по многим узлам.</p><p>Как и GiST, SP-GiST предназначен для разработки пользовательских типов данных с соответствующими методами доступа экспертом в области типа данных, а не экспертом по базам данных.</p><p>Часть информации здесь взята с веб-сайта проекта индексирования SP-GiST Университета Пердью. Реализацию SP-GiST в PostgreSQL в основном поддерживают Теодор Сигаев и Олег Бартунов, и на их веб-сайте есть дополнительная информация.</p><p>Основной дистрибутив PostgreSQL включает классы операторов SP-GiST, показанные в таблице 64.2.</p><p>Таблица 64.2. Встроенные классы операторов SP-GiST</p><p>Из двух классов операторов для типа point quad_point_ops является классом по умолчанию. kd_point_ops поддерживает те же операторы, но использует другую структуру данных индекса, которая может обеспечивать лучшую производительность в некоторых приложениях.</p><p>Классы операторов quad_point_ops, kd_point_ops и poly_ops поддерживают оператор упорядочения <->, который позволяет выполнять поиск по методу k-ближайших соседей (k-NN) по индексированным наборам данных точек или полигонов.</p><p>SP-GiST предлагает интерфейс с высоким уровнем абстракции, требующий от разработчика метода доступа реализовывать только методы, специфичные для данного типа данных. Ядро SP-GiST отвечает за эффективное отображение диска и поиск в древовидной структуре. Оно также заботится о параллелизме и логировании.</p><p>Листовые кортежи дерева SP-GiST обычно содержат значения того же типа данных, что и индексированный столбец, хотя они также могут содержать неточные представления индексированного столбца. Листовые кортежи, хранящиеся на корневом уровне, будут напрямую представлять исходное индексированное значение данных, но листовые кортежи на более низких уровнях могут содержать только частичное значение, например суффикс. В этом случае функции поддержки класса операторов должны иметь возможность реконструировать исходное значение, используя информацию, накопленную из внутренних кортежей, которые передаются для достижения листового уровня.</p><p>Когда индекс SP-GiST создается с помощью столбцов INCLUDE, значения этих столбцов также сохраняются в конечных кортежах. Столбцы INCLUDE не имеют отношения к классу операторов SP-GiST, поэтому они здесь далее не обсуждаются.</p><p>Внутренние кортежи более сложны, так как они являются точками ветвления в дереве поиска. Каждый внутренний кортеж содержит набор из одного или нескольких узлов, которые представляют группы схожих конечных значений. Узел содержит нисходящую ссылку, которая ведет либо к другому, более низкоуровневому внутреннему кортежу, либо к короткому списку конечных кортежей, которые все лежат на одной странице индекса. Каждый узел обычно имеет метку, которая его описывает; например, в радиксном дереве метка узла может быть следующим символом строкового значения. (В качестве альтернативы класс оператора может опустить метки узлов, если он работает с фиксированным набором узлов для всех внутренних кортежей; см. Раздел 64.3.4.2.) При желании внутренний кортеж может иметь значение префикса, которое описывает всех его членов. В радиксном дереве это может быть общий префикс представленных строк. Значение префикса не обязательно является настоящим префиксом, но может быть любыми данными, необходимыми классу оператора; например, в квадродереве он может хранить центральную точку, относительно которой измеряются четыре квадранта. Внутренний кортеж квадродерева тогда также будет содержать четыре узла, соответствующие квадрантам вокруг этой центральной точки.</p><p>Некоторые алгоритмы деревьев требуют знания уровня (или глубины) текущего кортежа, поэтому ядро ​​SP-GiST предоставляет возможность классам операторов управлять подсчетом уровней при спуске по дереву. Также есть поддержка для инкрементальной реконструкции представленного значения, когда это необходимо, и для передачи дополнительных данных (называемых значениями траверса) во время спуска по дереву.</p><p>Основной код SP-GiST обрабатывает записи null. Хотя индексы SP-GiST действительно хранят записи для null в индексированных столбцах, это скрыто от кода класса оператора индекса: никакие записи индекса null или условия поиска никогда не будут переданы методам класса оператора. (Предполагается, что операторы SP-GiST являются строгими и поэтому не могут успешно обрабатывать значения null.) Поэтому значения null здесь далее не обсуждаются.</p><p>Существует пять пользовательских методов, которые класс оператора индекса для SP-GiST должен предоставлять, и два из них являются необязательными. Все пять обязательных методов следуют соглашению о принятии двух внутренних аргументов, первый из которых является указателем на структуру C, содержащую входные значения для метода поддержки, в то время как второй аргумент является указателем на структуру C, куда должны быть помещены выходные значения. Четыре обязательных метода просто возвращают void, поскольку все их результаты появляются в выходной структуре; но leaf_consistent возвращает логический результат. Методы не должны изменять никакие поля своих входных структур. Во всех случаях выходная структура инициализируется нулями перед вызовом пользовательского метода. Необязательный шестой метод compress принимает данные для индексации в качестве единственного аргумента и возвращает значение, подходящее для физического хранения в листовом кортеже. Необязательный седьмой метод options принимает внутренний указатель на структуру C, куда должны быть помещены параметры, специфичные для opclass, и возвращает void.</p><p>Пять обязательных пользовательских методов:</p><p>Возвращает статическую информацию о реализации индекса, включая OID типов данных префикса и типов данных метки узла.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgConfigIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgConfigOut C, которую функция должна заполнить данными результата.</p><p>attType передается для поддержки полиморфных классов операторов индекса; для обычных классов операторов с фиксированным типом данных он всегда будет иметь одно и то же значение и поэтому может быть проигнорирован.</p><p>Для классов операторов, не использующих префиксы, prefixType может быть установлен в VOIDOID. Аналогично, для классов операторов, не использующих метки узлов, labelType может быть установлен в VOIDOID. canReturnData следует установить в true, если класс операторов способен восстановить изначально предоставленное значение индекса. longValuesOK следует установить в true, только если attType имеет переменную длину, а класс операторов способен сегментировать длинные значения путем повторного суффиксирования (см. раздел 64.3.4.1).</p><p>leafType должен соответствовать типу хранилища индекса, определенному записью каталога opckeytype класса оператора. (Обратите внимание, что opckeytype может быть равен нулю, подразумевая, что тип хранилища совпадает с типом ввода класса оператора, что является наиболее распространенной ситуацией.) Из соображений обратной совместимости метод config может установить leafType в какое-либо другое значение, и это значение будет использоваться; но это устарело, поскольку содержимое индекса затем неправильно идентифицируется в каталогах. Кроме того, допустимо оставить leafType неинициализированным (нулем); это интерпретируется как означающее тип хранилища индекса, полученный из opckeytype.</p><p>Если attType и leafType различны, необходимо предоставить необязательный метод compress. Метод compress отвечает за преобразование индексируемых данных из attType в leafType.</p><p>Выбирает метод вставки нового значения во внутренний кортеж.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgChooseIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgChooseOut C, которую функция должна заполнить данными результата.</p><p>datum — исходный datum типа spgConfigIn.attType, который должен был быть вставлен в индекс. leafDatum — значение типа spgConfigOut.leafType, которое изначально является результатом метода compress, примененного к datum, когда метод compress предоставляется, или тем же значением, что и datum в противном случае. leafDatum может изменяться на более низких уровнях дерева, если методы choose или picksplit изменяют его. Когда поиск вставки достигает листовой страницы, текущее значение leafDatum — это то, что будет сохранено во вновь созданном листовом кортеже. level — текущий уровень внутреннего кортежа, начиная с нуля для корневого уровня. allTheSame имеет значение true, если текущий внутренний кортеж помечен как содержащий несколько эквивалентных узлов (см. раздел 64.3.4.3). hasPrefix имеет значение true, если текущий внутренний кортеж содержит префикс; если это так, prefixDatum является его значением. nNodes — это количество дочерних узлов, содержащихся во внутреннем кортеже, а nodeLabels — это массив значений их меток или NULL, если меток нет.</p><p>Функция выбора может определить, что новое значение соответствует одному из существующих дочерних узлов, или что необходимо добавить новый дочерний узел, или что новое значение не соответствует префиксу кортежа, и поэтому внутренний кортеж необходимо разделить, чтобы создать менее ограничительный префикс.</p><p>Если новое значение совпадает с одним из существующих дочерних узлов, установите resultType на spgMatchNode. Установите nodeN на индекс (от нуля) этого узла в массиве узлов. Установите levelAdd на приращение уровня, вызванное спуском через этот узел, или оставьте его равным нулю, если класс оператора не использует уровни. Установите restDatum на значение leafDatum, если класс оператора не изменяет datums с одного уровня на другой, или в противном случае установите его на измененное значение, которое будет использоваться как leafDatum на следующем уровне.</p><p>Если необходимо добавить новый дочерний узел, установите resultType на spgAddNode. Установите nodeLabel на метку, которая будет использоваться для нового узла, и установите nodeN на индекс (от нуля), по которому следует вставить узел в массив узлов. После добавления узла функция select будет вызвана снова с измененным внутренним кортежем; этот вызов должен привести к результату spgMatchNode.</p><p>Если новое значение не соответствует префиксу кортежа, установите resultType на spgSplitTuple. Это действие перемещает все существующие узлы в новый внутренний кортеж нижнего уровня и заменяет существующий внутренний кортеж кортежем с одной нисходящей линией, указывающей на новый внутренний кортеж нижнего уровня. Установите prefixHasPrefix, чтобы указать, должен ли новый верхний кортеж иметь префикс, и если да, установите prefixPrefixDatum на значение префикса. Это новое значение префикса должно быть достаточно менее ограничивающим, чем исходное, чтобы принять новое значение для индексации. Установите prefixNNodes на количество узлов, необходимых в новом кортеже, и установите prefixNodeLabels на palloc'd массив, содержащий их метки, или на NULL, если метки узлов не требуются. Обратите внимание, что общий размер нового верхнего кортежа не должен превышать общий размер заменяемого им кортежа; это ограничивает длину нового префикса и новых меток. Установите childNodeN на индекс (от нуля) узла, который будет нисходить к новому внутреннему кортежу нижнего уровня. Установите postfixHasPrefix, чтобы указать, должен ли новый внутренний кортеж нижнего уровня иметь префикс, и если да, установите postfixPrefixDatum на значение префикса. Комбинация этих двух префиксов и метка нисходящего узла (если есть) должны иметь то же значение, что и исходный префикс, поскольку нет возможности изменить метки узлов, которые перемещаются в новый кортеж нижнего уровня, или изменить какие-либо записи дочернего индекса. После разделения узла функция choose будет вызвана снова с заменяющим внутренним кортежем. Этот вызов может вернуть результат spgAddNode, если действие spgSplitTuple не создало подходящего узла. В конечном итоге choose должен вернуть spgMatchNode, чтобы позволить вставке спуститься на следующий уровень.</p><p>Решает, как создать новый внутренний кортеж из набора конечных кортежей.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgPickSplitIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgPickSplitOut C, которую функция должна заполнить данными результата.</p><p>nTuples — это количество предоставленных конечных кортежей. datums — это массив их значений datum типа spgConfigOut.leafType. level — это текущий уровень, который разделяют все конечные кортежи, который станет уровнем нового внутреннего кортежа.</p><p>Установите hasPrefix, чтобы указать, должен ли новый внутренний кортеж иметь префикс, и если да, установите prefixDatum в значение префикса. Установите nNodes, чтобы указать количество узлов, которые будет содержать новый внутренний кортеж, и установите nodeLabels в массив их значений меток или в NULL, если метки узлов не требуются. Установите mapTuplesToNodes в массив, который дает индекс (от нуля) узла, которому должен быть назначен каждый листовой кортеж. Установите leafTupleDatums в массив значений, которые будут храниться в новых листовых кортежах (они будут такими же, как входные данные, если класс оператора не изменяет данные с одного уровня на другой). Обратите внимание, что функция picksplit отвечает за palloc'ing массивов nodeLabels, mapTuplesToNodes и leafTupleDatums.</p><p>Если указано более одного кортежа листьев, ожидается, что функция picksplit классифицирует их в более чем один узел; в противном случае невозможно разделить кортежи листьев по нескольким страницам, что является конечной целью этой операции. Поэтому, если функция picksplit в конечном итоге поместит все кортежи листьев в один и тот же узел, основной код SP-GiST переопределит это решение и сгенерирует внутренний кортеж, в котором кортежи листьев будут назначены случайным образом нескольким одинаково помеченным узлам. Такой кортеж помечается как allTheSame, чтобы обозначить, что это произошло. Функции choose и inner_consistent должны проявлять соответствующую осторожность с такими внутренними кортежами. Для получения дополнительной информации см. раздел 64.3.4.3.</p><p>picksplit можно применить к одному листовому кортежу только в том случае, если функция config установила longValuesOK в значение true и было предоставлено входное значение, превышающее страницу. В этом случае смысл операции заключается в удалении префикса и создании нового, более короткого листового значения данных. Вызов будет повторяться до тех пор, пока не будет создан листовой элемент данных, достаточно короткий для размещения на странице. Для получения дополнительной информации см. раздел 64.3.4.1.</p><p>Возвращает набор узлов (ветвей), которые необходимо отслеживать при поиске по дереву.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgInnerConsistentIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgInnerConsistentOut C, которую функция должна заполнить данными результата.</p><p>Массив scankeys длиной nkeys описывает условие(я) поиска индекса. Эти условия объединяются с помощью AND — интересны только записи индекса, которые удовлетворяют всем им. (Обратите внимание, что nkeys = 0 подразумевает, что все записи индекса удовлетворяют запросу.) Обычно функция conformity заботится только о полях sk_strategy и sk_argument каждой записи массива, которые соответственно дают индексируемый оператор и значение сравнения. В частности, нет необходимости проверять sk_flags, чтобы увидеть, является ли значение сравнения NULL, поскольку основной код SP-GiST отфильтрует такие условия. Массив orderbys длиной norderbys описывает операторы упорядочивания (если таковые имеются) таким же образом. reformedValue — это значение, восстановленное для родительского кортежа; оно равно (Datum) 0 на корневом уровне или если функция inner_consistent не предоставила значение на родительском уровне. traversalValue — указатель на любые данные траверса, переданные из предыдущего вызова inner_consistent в родительском индексном кортеже, или NULL на корневом уровне. traversalMemoryContext — контекст памяти, в котором хранятся выходные значения траверса (см. ниже). level — текущий уровень внутреннего кортежа, начинающийся с нуля для корневого уровня. returnData — true, если для этого запроса требуются восстановленные данные; это будет так, только если функция конфигурации заявила canReturnData. allTheSame — true, если текущий внутренний кортеж помечен как «все то же самое»; в этом случае все узлы имеют одинаковую метку (если таковая имеется), и поэтому либо все, либо ни один из них не соответствуют запросу (см. раздел 64.3.4.3). hasPrefix — true, если текущий внутренний кортеж содержит префикс; если это так, prefixDatum — его значение. nNodes — это количество дочерних узлов, содержащихся во внутреннем кортеже, а nodeLabels — это массив значений их меток или NULL, если у узлов нет меток.</p><p>nNodes должен быть установлен на количество дочерних узлов, которые необходимо посетить при поиске, а nodeNumbers должен быть установлен на массив их индексов. Если класс оператора отслеживает уровни, установите levelAdds на массив приращений уровня, необходимых при спуске к каждому посещаемому узлу. (Часто эти приращения будут одинаковыми для всех узлов, но это не обязательно так, поэтому используется массив.) Если требуется реконструкция значений, установите reformedValues ​​на массив значений, реконструированных для каждого посещаемого дочернего узла; в противном случае оставьте reformedValues ​​как NULL. Предполагается, что реконструированные значения имеют тип spgConfigOut.leafType. (Однако, поскольку основная система ничего не будет с ними делать, кроме как, возможно, скопирует их, достаточно, чтобы они имели те же свойства typlen и typbyval, что и leafType.) Если выполняется упорядоченный поиск, установите distances на массив значений расстояний в соответствии с массивом orderbys (узлы с наименьшими расстояниями будут обработаны первыми). В противном случае оставьте NULL. Если требуется передать дополнительную внеполосную информацию («значения траверса») на нижние уровни поиска по дереву, установите traversalValues ​​в массив соответствующих значений траверса, по одному для каждого дочернего узла, который нужно посетить; в противном случае оставьте traversalValues ​​как NULL. Обратите внимание, что функция inner_consistent отвечает за palloc'ing массивов nodeNumbers, levelAdds, distances, reformedValues ​​и traversalValues ​​в текущем контексте памяти. Однако любые выходные значения траверса, на которые указывает массив traversalValues, должны быть выделены в traversalMemoryContext. Каждое значение траверса должно быть отдельным palloc'ed chunk.</p><p>Возвращает значение true, если конечный кортеж удовлетворяет запросу.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgLeafConsistentIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgLeafConsistentOut C, которую функция должна заполнить данными результата.</p><p>Массив scankeys длиной nkeys описывает условие(я) поиска индекса. Эти условия объединяются с помощью AND — только записи индекса, которые удовлетворяют всем им, удовлетворяют запросу. (Обратите внимание, что nkeys = 0 подразумевает, что все записи индекса удовлетворяют запросу.) Обычно функция conformity заботится только о полях sk_strategy и sk_argument каждой записи массива, которые соответственно дают индексируемый оператор и значение сравнения. В частности, нет необходимости проверять sk_flags, чтобы увидеть, является ли значение сравнения NULL, поскольку основной код SP-GiST отфильтрует такие условия. Массив orderbys длиной norderbys описывает операторы упорядочивания таким же образом. reformedValue — это значение, восстановленное для родительского кортежа; оно равно (Datum) 0 на корневом уровне или если функция inner_consistent не предоставила значение на родительском уровне. traversalValue — указатель на любые данные траверса, переданные из предыдущего вызова inner_consistent в родительском кортеже индекса, или NULL на корневом уровне. level — уровень текущего листового кортежа, начинающийся с нуля для корневого уровня. returnData имеет значение true, если для этого запроса требуются реконструированные данные; это будет так, только если функция конфигурации подтвердила canReturnData. leafDatum — ключевое значение spgConfigOut.leafType, хранящееся в текущем листовом кортеже.</p><p>Функция должна возвращать true, если конечный кортеж соответствует запросу, или false, если нет. В случае true, если returnData имеет значение true, то leafValue должно быть установлено на значение (типа spgConfigIn.attType), изначально предоставленное для индексации для этого конечного кортежа. Кроме того, recheck может быть установлено на true, если соответствие неопределенное, и поэтому оператор(ы) должны быть повторно применены к фактическому кортежу кучи для проверки соответствия. Если выполняется упорядоченный поиск, установите расстояния в массив значений расстояний в соответствии с массивом orderbys. В противном случае оставьте его NULL. Если хотя бы одно из возвращенных расстояний не является точным, установите recheckDistances на true. В этом случае исполнитель вычислит точные расстояния после извлечения кортежа из кучи и при необходимости переупорядочит кортежи.</p><p>Необязательные определяемые пользователем методы:</p><p>Преобразует элемент данных в формат, подходящий для физического хранения в листовом кортеже индекса. Принимает значение типа spgConfigIn.attType и возвращает значение типа spgConfigOut.leafType. Выходное значение не должно содержать внешний указатель TOAST.</p><p>Примечание: метод сжатия применяется только к значениям, которые необходимо сохранить. Последовательные методы получают ключи сканирования запросов без изменений, без преобразования с помощью сжатия.</p><p>Определяет набор видимых пользователю параметров, которые управляют поведением класса оператора.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Функция передает указатель на структуру local_relopts, которую необходимо заполнить набором опций, специфичных для класса оператора. Доступ к опциям можно получить из других функций поддержки с помощью макросов PG_HAS_OPCLASS_OPTIONS() и PG_GET_OPCLASS_OPTIONS().</p><p>Поскольку представление ключа в SP-GiST является гибким, оно может зависеть от указанных пользователем параметров.</p><p>Все методы поддержки SP-GiST обычно вызываются в кратковременном контексте памяти; то есть CurrentMemoryContext будет сброшен после обработки каждого кортежа. Поэтому не так уж важно беспокоиться о pfree'е всего, что вы palloc. (Метод config является исключением: он должен попытаться избежать утечки памяти. Но обычно метод config не должен ничего делать, кроме как назначать константы в переданную структуру параметров.)</p><p>Если индексированный столбец имеет тип данных, поддающийся сортировке, сортировка индекса будет передана всем методам поддержки с использованием стандартного механизма PG_GET_COLLATION().</p><p>В этом разделе рассматриваются детали реализации и другие приемы, которые полезно знать разработчикам классов операторов SP-GiST.</p><p>Отдельные кортежи листьев и внутренние кортежи должны помещаться на одной странице индекса (по умолчанию 8 КБ). Поэтому при индексировании значений типов данных переменной длины длинные значения могут поддерживаться только такими методами, как radix trees, в которых каждый уровень дерева включает префикс, который достаточно короток для размещения на странице, а последний уровень листьев включает суффикс, также достаточно короток для размещения на странице. Класс оператора должен устанавливать longValuesOK в значение true, только если он готов это организовать. В противном случае ядро ​​SP-GiST отклонит любой запрос на индексирование значения, которое слишком велико для размещения на странице индекса.</p><p>Аналогично, класс операторов отвечает за то, чтобы внутренние кортежи не становились слишком большими, чтобы поместиться на странице индекса; это ограничивает количество дочерних узлов, которые могут использоваться в одном внутреннем кортеже, а также максимальный размер значения префикса.</p><p>Другое ограничение заключается в том, что когда узел внутреннего кортежа указывает на набор конечных кортежей, все эти кортежи должны находиться на одной странице индекса. (Это проектное решение для сокращения поиска и экономии места в ссылках, которые связывают такие кортежи вместе.) Если набор конечных кортежей становится слишком большим для страницы, выполняется разделение и вставляется промежуточный внутренний кортеж. Чтобы это исправило проблему, новый внутренний кортеж должен разделить набор конечных значений на более чем одну группу узлов. Если функция picksplit класса оператора не может этого сделать, ядро ​​SP-GiST прибегает к чрезвычайным мерам, описанным в разделе 64.3.4.3.</p><p>Когда longValuesOK имеет значение true, ожидается, что последующие уровни дерева SP-GiST будут поглощать все больше и больше информации в префиксы и метки узлов внутренних кортежей, делая требуемый листовой элемент данных все меньше и меньше, так что в конечном итоге он поместится на странице. Чтобы предотвратить возникновение бесконечных циклов вставки из-за ошибок в классах операторов, ядро ​​SP-GiST выдаст ошибку, если листовой элемент данных не станет меньше в течение десяти циклов вызовов метода select.</p><p>Некоторые алгоритмы деревьев используют фиксированный набор узлов для каждого внутреннего кортежа; например, в квадродереве всегда ровно четыре узла, соответствующих четырем квадрантам вокруг точки центроида внутреннего кортежа. В таком случае код обычно работает с узлами по номеру, и нет необходимости в явных метках узлов. Чтобы подавить метки узлов (и тем самым сэкономить немного места), функция picksplit может возвращать NULL для массива nodeLabels, и аналогично функция choose может возвращать NULL для массива prefixNodeLabels во время действия spgSplitTuple. Это, в свою очередь, приведет к тому, что nodeLabels будет NULL во время последующих вызовов choose и inner_consistent. В принципе, метки узлов могут использоваться для некоторых внутренних кортежей и опускаться для других в том же индексе.</p><p>При работе с внутренним кортежем, имеющим непомеченные узлы, выбор возврата spgAddNode является ошибкой, поскольку в таких случаях предполагается, что набор узлов фиксирован.</p><p>Ядро SP-GiST может переопределить результаты функции picksplit класса оператора, когда picksplit не может разделить предоставленные значения листьев по крайней мере на две категории узлов. Когда это происходит, создается новый внутренний кортеж с несколькими узлами, каждый из которых имеет ту же метку (если таковая имеется), которую picksplit дал одному узлу, который он использовал, и значения листьев случайным образом распределяются между этими эквивалентными узлами. Флаг allTheSame устанавливается на внутреннем кортеже, чтобы предупредить функции select и inner_consistent о том, что кортеж не имеет набора узлов, который они могли бы ожидать в противном случае.</p><p>При работе с кортежем allTheSame результат выбора spgMatchNode интерпретируется как означающий, что новое значение может быть назначено любому из эквивалентных узлов; основной код проигнорирует предоставленное значение nodeN и спустится в один из узлов случайным образом (чтобы сохранить сбалансированность дерева). Возвращение spgAddNode является ошибкой выбора, поскольку это сделало бы не все узлы эквивалентными; действие spgSplitTuple должно использоваться, если вставляемое значение не соответствует существующим узлам.</p><p>При работе с кортежем allTheSame функция inner_consistent должна возвращать либо все, либо ни одного узла в качестве целей для продолжения поиска индекса, поскольку все они эквивалентны. Это может потребовать или не потребовать специального кода, в зависимости от того, насколько функция inner_consistent обычно предполагает значение узлов.</p><p>Исходный дистрибутив PostgreSQL включает несколько примеров классов операторов индекса для SP-GiST, как описано в Таблице 64.2. Посмотрите в src/backend/access/spgist/ и src/backend/utils/adt/, чтобы увидеть код.</p>