<h2>64.1. B-Tree Indexes #</h2>
<p>PostgreSQL включает реализацию стандартной структуры индекса btree (многоканальное сбалансированное дерево). Любой тип данных, который может быть отсортирован в четко определенном линейном порядке, может быть проиндексирован индексом btree. Единственное ограничение заключается в том, что запись индекса не может превышать приблизительно одну треть страницы (после сжатия TOAST, если применимо).</p><p>Поскольку каждый класс операторов btree накладывает порядок сортировки на свой тип данных, классы операторов btree (или, на самом деле, семейства операторов) стали использоваться в качестве общего представления и понимания семантики сортировки PostgreSQL. Поэтому они приобрели некоторые функции, выходящие за рамки того, что было бы необходимо только для поддержки индексов btree, и части системы, которые довольно далеки от AM btree, используют их.</p><p>Как показано в таблице 36.3, класс операторов btree должен предоставлять пять операторов сравнения: <, <=, =, >= и >. Можно было бы ожидать, что <> также должен быть частью класса операторов, но это не так, поскольку почти никогда не будет полезно использовать предложение <> WHERE в поиске по индексу. (Для некоторых целей планировщик рассматривает <> как связанный с классом операторов btree; но он находит этот оператор через отрицательную ссылку оператора =, а не из pg_amop.)</p><p>Когда несколько типов данных разделяют почти идентичную семантику сортировки, их классы операторов могут быть сгруппированы в семейство операторов. Это выгодно, поскольку позволяет планировщику делать выводы о сравнениях между типами. Каждый класс операторов в семействе должен содержать операторы одного типа (и связанные с ними функции поддержки) для своего типа входных данных, в то время как операторы сравнения между типами и функции поддержки «свободны» в семействе. Рекомендуется, чтобы полный набор операторов между типами был включен в семейство, таким образом гарантируя, что планировщик может представлять любые условия сравнения, которые он выводит из транзитивности.</p><p>Существуют некоторые основные предположения, которым должно удовлетворять семейство операторов B-Tree:</p><p>Оператор = должен быть отношением эквивалентности, то есть для всех ненулевых значений A, B, C типа данных:</p><p>A = A верно (рефлексивный закон)</p><p>если A = B, то B = A (симметричный закон)</p><p>если A = B и B = C, то A = C (транзитивный закон)</p><p>Оператор < должен быть строгим упорядочивающим отношением; то есть для всех ненулевых значений A, B, C:</p><p>A < A ложно (иррефлексивный закон)</p><p>если A < B и B < C, то A < C (транзитивный закон)</p><p>Более того, упорядочение является полным, то есть для всех ненулевых значений A, B:</p><p>ровно одно из утверждений A < B, A = B и B < A верно (закон трихотомии)</p><p>(Конечно, закон трихотомии оправдывает определение функции поддержки сравнения.)</p><p>Остальные три оператора очевидным образом определяются в терминах = и < и должны действовать согласованно с ними.</p><p>Для семейства операторов, поддерживающего несколько типов данных, вышеуказанные законы должны выполняться, когда A, B, C берутся из любых типов данных в семействе. Транзитивные законы сложнее всего обеспечить, так как в ситуациях с перекрестными типами они представляют утверждения о том, что поведение двух или трех различных операторов является согласованным. Например, не будет работать помещение float8 и numeric в одно и то же семейство операторов, по крайней мере, не с текущей семантикой, согласно которой числовые значения преобразуются в float8 для сравнения с float8. Из-за ограниченной точности float8 это означает, что существуют различные числовые значения, которые будут сравниваться равными одному и тому же значению float8, и, таким образом, транзитивный закон не будет работать.</p><p>Еще одним требованием к семейству с несколькими типами данных является то, что любые неявные или двоичные приведения, определенные между типами данных, включенными в семейство операторов, не должны изменять связанный порядок сортировки.</p><p>Должно быть достаточно ясно, почему индекс btree требует, чтобы эти законы соблюдались в пределах одного типа данных: без них нет порядка, с которым можно было бы упорядочить ключи. Кроме того, поиск индекса с использованием ключа сравнения другого типа данных требует, чтобы сравнения вели себя разумно по двум типам данных. Расширения до трех или более типов данных в пределах семейства не являются строго обязательными для самого механизма индекса btree, но планировщик полагается на них в целях оптимизации.</p><p>Как показано в Таблице 36.9, btree определяет одну обязательную и четыре необязательные функции поддержки. Пять определяемых пользователем методов:</p><p>Для каждой комбинации типов данных, для которых семейство операторов btree предоставляет операторы сравнения, оно должно предоставлять функцию поддержки сравнения, зарегистрированную в pg_amproc с функцией поддержки номер 1 и amproclefttype/amprocrighttype, равными левому и правому типам данных для сравнения (т. е. тем же типам данных, с которыми зарегистрированы соответствующие операторы в pg_amop). Функция сравнения должна принимать два непустых значения A и B и возвращать значение int32, которое < 0, 0 или > 0, когда A < B, A = B или A > B соответственно. Нулевой результат не допускается: все значения типа данных должны быть сравнимы. См. src/backend/access/nbtree/nbtcompare.c для примеров.</p><p>Если сравниваемые значения имеют тип данных, поддающийся сопоставлению, соответствующий идентификатор объекта сопоставления будет передан в функцию поддержки сравнения с использованием стандартного механизма PG_GET_COLLATION().</p><p>При желании семейство операторов btree может предоставлять функцию(и) поддержки сортировки, зарегистрированную под номером функции поддержки 2. Эти функции позволяют реализовывать сравнения для целей сортировки более эффективным способом, чем наивный вызов функции поддержки сравнения. API, задействованные в этом, определены в src/include/utils/sortsupport.h.</p><p>При желании семейство операторов btree может предоставлять функцию(и) поддержки in_range, зарегистрированную под номером функции поддержки 3. Они не используются во время операций индекса btree; вместо этого они расширяют семантику семейства операторов, чтобы оно могло поддерживать предложения окна, содержащие типы рамок RANGE offset PRECEDING и RANGE offset FOLLOWING (см. раздел 4.2.8). По сути, дополнительная информация, предоставляемая, заключается в том, как добавлять или вычитать значение смещения способом, совместимым с порядком данных семейства.</p><p>Функция in_range должна иметь сигнатуру</p><p>val и base должны быть одного типа, который является одним из типов, поддерживаемых семейством операторов (т. е. типом, для которого он обеспечивает упорядочивание). Однако offset может быть другого типа, который может быть неподдерживаемым семейством. Примером является то, что встроенное семейство time_ops предоставляет функцию in_range, которая имеет смещение типа interval. Семейство может предоставлять функции in_range для любого из поддерживаемых им типов и одного или нескольких типов смещения. Каждая функция in_range должна быть введена в pg_amproc с amproclefttype, равным type1, и amprocrighttype, равным type2.</p><p>Основная семантика функции in_range зависит от двух параметров булевых флагов. Она должна добавлять или вычитать base и offset, а затем сравнивать val с результатом следующим образом:</p><p>если !sub и !less, вернуть значение >= (база + смещение)</p><p>если !sub и меньше, вернуть значение <= (база + смещение)</p><p>если sub и !less, вернуть значение >= (база - смещение)</p><p>если sub и меньше, вернуть значение <= (base - offset)</p><p>Перед этим функция должна проверить знак смещения: если он меньше нуля, выдать ошибку ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE (22013) с текстом ошибки типа «недопустимый предшествующий или последующий размер в оконной функции». (Этого требует стандарт SQL, хотя нестандартные семейства операторов, возможно, предпочтут проигнорировать это ограничение, поскольку в нем, по-видимому, мало семантической необходимости.) Это требование делегировано функции in_range, чтобы базовому коду не нужно было понимать, что означает «меньше нуля» для конкретного типа данных.</p><p>Дополнительное ожидание заключается в том, что функции in_range должны, если это практически осуществимо, избегать выдачи ошибки, если base + offset или base - offset приведет к переполнению. Правильный результат сравнения может быть определен, даже если это значение будет вне диапазона типа данных. Обратите внимание, что если тип данных включает такие концепции, как «бесконечность» или «NaN», может потребоваться дополнительная осторожность, чтобы гарантировать, что результаты in_range согласуются с нормальным порядком сортировки семейства операторов.</p><p>Результаты функции in_range должны соответствовать порядку сортировки, налагаемому семейством операторов. Если быть точным, то при любых фиксированных значениях offset и sub:</p><p>Если in_range с less = true является истинным для некоторых val1 и base, то он должен быть истинным для каждого val2 <= val1 с той же базой.</p><p>Если in_range с less = true является ложным для некоторых val1 и base, он должен быть ложным для каждого val2 >= val1 с тем же base.</p><p>Если in_range с less = true является истинным для некоторых val и base1, то он должен быть истинным для всех base2 >= base1 с тем же val.</p><p>Если in_range с less = true имеет значение false для некоторых val и base1, оно должно быть false для всех base2 <= base1 с тем же val.</p><p>Аналогичные утверждения с обратными условиями справедливы, когда меньше = ложь.</p><p>Если упорядочиваемый тип (type1) является сортируемым, соответствующий OID сортировки будет передан функции in_range с использованием стандартного механизма PG_GET_COLLATION().</p><p>Функции in_range не обязаны обрабатывать входные данные NULL и обычно помечаются как строгие.</p><p>При желании семейство операторов btree может предоставлять функции поддержки equalimage («равенство подразумевает равенство изображений»), зарегистрированные под номером функции поддержки 4. Эти функции позволяют основному коду определять, когда безопасно применять оптимизацию дедупликации btree. В настоящее время функции equalimage вызываются только при построении или перестроении индекса.</p><p>Функция equalimage должна иметь сигнатуру</p><p>Возвращаемое значение — статическая информация о классе операторов и сортировке. Возврат true указывает на то, что функция order для класса операторов гарантированно вернет только 0 («аргументы равны»), когда ее аргументы A и B также взаимозаменяемы без потери семантической информации. Отсутствие регистрации функции equalimage или возврат false указывает на то, что это условие не может считаться выполненным.</p><p>Аргумент opcintype — это pg_type.oid типа данных, который индексирует класс оператора. Это удобство, которое позволяет повторно использовать одну и ту же базовую функцию equalimage в классах операторов. Если opcintype — это тип данных, поддающийся сортировке, соответствующий идентификатор сопоставления будет передан функции equalimage с использованием стандартного механизма PG_GET_COLLATION().</p><p>Что касается класса оператора, возвращение true указывает на то, что дедупликация безопасна (или безопасна для сопоставления, OID которого был передан его функции equalimage). Однако основной код будет считать дедупликацию безопасной для индекса только тогда, когда каждый индексированный столбец использует класс оператора, который регистрирует функцию equalimage, и каждая функция фактически возвращает true при вызове.</p><p>Равенство изображений — это почти то же самое условие, что и простое побитовое равенство. Есть одно тонкое отличие: при индексации типа данных varlena дисковое представление двух равных изображений может не быть побитовым равным из-за непоследовательного применения сжатия TOAST на входе. Формально, когда функция equalimage класса операторов возвращает true, можно с уверенностью предположить, что функция datum_image_eq() C всегда будет согласовываться с функцией order класса операторов (при условии, что функциям equalimage и order передается один и тот же OID сортировки).</p><p>Основной код принципиально не способен вывести что-либо о статусе «равенство подразумевает равенство изображений» класса операторов в семействе с несколькими типами данных на основе сведений из других классов операторов в том же семействе. Кроме того, для семейства операторов не имеет смысла регистрировать функцию equalimage для кросс-типов, и попытка сделать это приведет к ошибке. Это связано с тем, что статус «равенство подразумевает равенство изображений» зависит не только от семантики сортировки/равенства, которая более или менее определена на уровне семейства операторов. В общем, семантику, которую реализует один конкретный тип данных, следует рассматривать отдельно.</p><p>Соглашение, которому следуют классы операторов, включенные в основной дистрибутив PostgreSQL, заключается в регистрации стандартной, универсальной функции equalimage. Большинство классов операторов регистрируют btequalimage(), что указывает на безусловную безопасность дедупликации. Классы операторов для типов данных, поддающихся сортировке, таких как текст, регистрируют btvarstrequalimage(), что указывает на безопасность дедупликации с детерминированными сортировками. Лучшая практика для сторонних расширений — регистрировать собственную пользовательскую функцию для сохранения контроля.</p><p>При желании семейство операторов B-дерева может предоставлять функции поддержки опций («опции, специфичные для класса операторов»), зарегистрированные под номером функции поддержки 5. Эти функции определяют набор видимых пользователю параметров, которые управляют поведением класса операторов.</p><p>Функция поддержки опций должна иметь сигнатуру</p><p>Функция передает указатель на структуру local_relopts, которую необходимо заполнить набором опций, специфичных для класса оператора. Доступ к опциям можно получить из других функций поддержки с помощью макросов PG_HAS_OPCLASS_OPTIONS() и PG_GET_OPCLASS_OPTIONS().</p><p>В настоящее время ни один класс операторов B-Tree не имеет функции поддержки опций. B-tree не допускает гибкого представления ключей, как GiST, SP-GiST, GIN и BRIN. Поэтому опции, вероятно, не имеют особого применения в текущем методе доступа к индексу B-tree. Тем не менее, эта функция поддержки была добавлена ​​в B-tree для единообразия и, вероятно, найдет применение в ходе дальнейшей эволюции B-tree в PostgreSQL.</p><p>В этом разделе рассматриваются детали реализации индекса B-Tree, которые могут быть полезны продвинутым пользователям. См. src/backend/access/nbtree/README в исходном дистрибутиве для гораздо более подробного, сфокусированного на внутренних компонентах описания реализации B-Tree.</p><p>Индексы PostgreSQL B-Tree представляют собой многоуровневые древовидные структуры, в которых каждый уровень дерева может использоваться как двусвязный список страниц. Одна метастраница хранится в фиксированном положении в начале первого сегментного файла индекса. Все остальные страницы являются либо конечными страницами, либо внутренними страницами. Конечные страницы — это страницы на самом нижнем уровне дерева. Все остальные уровни состоят из внутренних страниц. Каждая конечная страница содержит кортежи, указывающие на строки таблицы. Каждая внутренняя страница содержит кортежи, указывающие на следующий уровень ниже в дереве. Обычно более 99% всех страниц являются конечными страницами. Как внутренние страницы, так и конечные страницы используют стандартный формат страницы, описанный в разделе 65.6.</p><p>Новые листовые страницы добавляются в индекс B-Tree, когда существующая листовая страница не может вместить входящий кортеж. Операция разделения страницы освобождает место для элементов, которые изначально принадлежали переполненной странице, перемещая часть элементов на новую страницу. Разделения страниц также должны вставлять новую нисходящую ссылку на новую страницу в родительской странице, что может привести к разделению родительской страницы в свою очередь. Разделения страниц «каскадируются вверх» рекурсивным образом. Когда корневая страница наконец не может вместить новую нисходящую ссылку, происходит операция разделения корневой страницы. Это добавляет новый уровень в структуру дерева, создавая новую корневую страницу, которая находится на один уровень выше исходной корневой страницы.</p><p>Индексы B-Tree напрямую не знают, что в MVCC может быть несколько существующих версий одной и той же логической строки таблицы; для индекса каждый кортеж является независимым объектом, которому нужна своя собственная запись индекса. Кортежи «переключения версий» иногда могут накапливаться и отрицательно влиять на задержку запроса и пропускную способность. Обычно это происходит при интенсивной рабочей нагрузке UPDATE, когда большинство отдельных обновлений не могут применить оптимизацию HOT. Изменение значения только одного столбца, охватываемого одним индексом, во время UPDATE всегда требует нового набора кортежей индекса — по одному для каждого индекса в таблице. Обратите внимание, что это включает индексы, которые не были «логически изменены» UPDATE. Всем индексам потребуется последующий физический кортеж индекса, который указывает на последнюю версию в таблице. Каждый новый кортеж в каждом индексе, как правило, должен сосуществовать с исходным «обновленным» кортежем в течение короткого периода времени (обычно вскоре после фиксации транзакции UPDATE).</p><p>Индексы B-Tree постепенно удаляют кортежи индекса смены версий, выполняя проходы удаления индекса снизу вверх. Каждый проход удаления запускается в ответ на ожидаемое «разделение страницы смены версий». Это происходит только с индексами, которые логически не изменяются операторами UPDATE, где в противном случае произошло бы концентрированное накопление устаревших версий на определенных страницах. Разделение страницы обычно избегается, хотя возможно, что определенные эвристики на уровне реализации не смогут идентифицировать и удалить даже один мусорный кортеж индекса (в этом случае разделение страницы или проход дедупликации решают проблему входящего нового кортежа, не помещающегося на листовой странице). Наихудшее количество версий, которое должно пройти любое сканирование индекса (для любой отдельной логической строки), является важным фактором общей отзывчивости и пропускной способности системы. Проход удаления индекса снизу вверх нацелен на предполагаемые мусорные кортежи на одной листовой странице на основе качественных различий, включающих логические строки и версии. Это контрастирует с очисткой индекса «сверху вниз», выполняемой работниками автоочистки, которая запускается при превышении определенных количественных пороговых значений на уровне таблицы (см. раздел 24.1.6).</p><p>Не все операции удаления, выполняемые в индексах B-Tree, являются операциями удаления снизу вверх. Существует отдельная категория удаления кортежей индексов: простое удаление кортежей индексов. Это отложенная операция обслуживания, которая удаляет кортежи индексов, которые, как известно, можно безопасно удалить (те, у которых бит идентификатора элемента LP_DEAD уже установлен). Как и удаление индексов снизу вверх, простое удаление индексов происходит в точке, где ожидается разделение страницы, как способ избежать разделения.</p><p>Простое удаление является оппортунистическим в том смысле, что оно может иметь место только тогда, когда недавние сканирования индекса устанавливают биты LP_DEAD затронутых элементов попутно. До PostgreSQL 14 единственной категорией удаления B-Tree было простое удаление. Основные различия между ним и удалением снизу вверх заключаются в том, что только первое оппортунистически обусловлено активностью прохождения сканирования индекса, тогда как только последнее специально нацелено на смену версий из UPDATE, которые логически не изменяют индексированные столбцы.</p><p>Удаление индекса снизу вверх выполняет подавляющее большинство всех очисток мусорных кортежей индекса для определенных индексов с определенными рабочими нагрузками. Это ожидается с любым индексом B-Tree, который подвержен значительному изменению версий из-за ОБНОВЛЕНИЙ, которые редко или никогда логически не изменяют столбцы, которые охватывает индекс. Среднее и худшее число версий на логическую строку можно поддерживать на низком уровне исключительно за счет целевых инкрементных проходов удаления. Вполне возможно, что размер определенных индексов на диске никогда не увеличится даже на одну страницу/блок, несмотря на постоянное изменение версий из-за ОБНОВЛЕНИЙ. Даже в этом случае в конечном итоге потребуется исчерпывающая «чистка» с помощью операции VACUUM (обычно выполняемой в рабочем процессе автовакуума) как часть коллективной очистки таблицы и каждого из ее индексов.</p><p>В отличие от VACUUM, удаление индекса снизу вверх не дает никаких надежных гарантий относительно того, насколько старым может быть самый старый мусорный кортеж индекса. Ни одному индексу не может быть разрешено сохранять «плавающие мусорные» кортежи индекса, которые стали мертвыми до консервативной точки отсечения, общей для таблицы и всех ее индексов в совокупности. Этот фундаментальный инвариант уровня таблицы делает безопасным повторное использование TID таблиц. Вот как различные логические строки могут повторно использовать один и тот же TID таблицы с течением времени (хотя это никогда не может произойти с двумя логическими строками, чье время жизни охватывает один и тот же цикл VACUUM).</p><p>Дубликат — это кортеж листовой страницы (кортеж, указывающий на строку таблицы), где все индексированные ключевые столбцы имеют значения, которые соответствуют значениям столбцов из по крайней мере одного другого кортежа листовой страницы в том же индексе. Дублирующие кортежи довольно распространены на практике. Индексы B-Tree могут использовать специальное, эффективное по пространству представление для дубликатов, когда включена дополнительная техника: дедупликация.</p><p>Дедупликация работает путем периодического слияния групп дублирующихся кортежей вместе, образуя один кортеж списка постинга для каждой группы. Значение(я) ключа столбца появляются только один раз в этом представлении. Затем следует отсортированный массив TID, которые указывают на строки в таблице. Это значительно уменьшает размер хранилища индексов, где каждое значение (или каждая отдельная комбинация значений столбцов) появляется несколько раз в среднем. Задержка запросов может быть значительно уменьшена. Общая пропускная способность запросов может значительно увеличиться. Накладные расходы на рутинную очистку индекса также могут быть значительно уменьшены.</p><p>Дедупликация B-Tree столь же эффективна с «дубликатами», содержащими значение NULL, хотя значения NULL никогда не равны друг другу согласно члену = любого класса операторов B-Tree. Что касается любой части реализации, которая понимает структуру B-Tree на диске, NULL — это просто еще одно значение из области индексированных значений.</p><p>Процесс дедупликации происходит лениво, когда вставляется новый элемент, который не может поместиться на существующей конечной странице, но только когда удаление индексного кортежа не может освободить достаточно места для нового элемента (обычно удаление кратко рассматривается и затем пропускается). В отличие от кортежей списков размещения GIN, кортежи списков размещения B-Tree не нужно расширять каждый раз при вставке нового дубликата; они являются просто альтернативным физическим представлением исходного логического содержимого конечной страницы. Такая конструкция отдает приоритет стабильной производительности при смешанных рабочих нагрузках чтения-записи. Большинство клиентских приложений по крайней мере увидят умеренное улучшение производительности от использования дедупликации. Дедупликация включена по умолчанию.</p><p>CREATE INDEX и REINDEX применяют дедупликацию для создания кортежей списков постинга, хотя стратегия, которую они используют, немного отличается. Каждая группа дубликатов обычных кортежей, обнаруженных в отсортированном вводе, взятом из таблицы, объединяется в кортеж списка постинга перед добавлением к текущей ожидающей конечной странице. Отдельные кортежи списков постинга заполняются максимально возможным количеством TID. Конечные страницы записываются обычным способом, без отдельного прохода дедупликации. Эта стратегия хорошо подходит для CREATE INDEX и REINDEX, поскольку они являются одноразовыми пакетными операциями.</p><p>Рабочие нагрузки с большой нагрузкой на запись, которые не получают выгоды от дедупликации из-за малого количества или отсутствия дубликатов значений в индексах, повлекут за собой небольшое фиксированное снижение производительности (если только дедупликация явно не отключена). Параметр хранилища deduplicate_items можно использовать для отключения дедупликации в отдельных индексах. С рабочими нагрузками только для чтения никогда не происходит никакого снижения производительности, поскольку чтение кортежей списков постинга по крайней мере так же эффективно, как и чтение стандартного представления кортежа. Отключение дедупликации обычно не помогает.</p><p>Иногда уникальные индексы (а также уникальные ограничения) могут использовать дедупликацию. Это позволяет конечным страницам временно «поглощать» дополнительные дубликаты версий. Дедупликация в уникальных индексах усиливает удаление индекса снизу вверх, особенно в случаях, когда длительная транзакция удерживает снимок, который блокирует сборку мусора. Цель состоит в том, чтобы выиграть время для того, чтобы стратегия удаления индекса снизу вверх снова стала эффективной. Отсрочка разделения страниц до тех пор, пока одна длительная транзакция естественным образом не исчезнет, ​​может позволить проходу удаления снизу вверх быть успешным там, где более ранний проход удаления не удался.</p><p>Специальная эвристика применяется для определения того, следует ли выполнять проход дедупликации в уникальном индексе. Часто она может перейти сразу к разделению листовой страницы, избегая снижения производительности из-за траты циклов на бесполезные проходы дедупликации. Если вас беспокоят накладные расходы на дедупликацию, рассмотрите возможность выборочной установки deduplicate_items = off. Оставленная включенной дедупликация в уникальных индексах имеет мало недостатков.</p><p>Дедупликацию нельзя использовать во всех случаях из-за ограничений на уровне реализации. Безопасность дедупликации определяется при запуске CREATE INDEX или REINDEX.</p><p>Обратите внимание, что дедупликация считается небезопасной и не может использоваться в следующих случаях, когда имеются семантически значимые различия между одинаковыми данными:</p><p>text, varchar и char не могут использовать дедупликацию, когда используется недетерминированное сопоставление. Различия в регистре и акценте должны быть сохранены среди одинаковых данных.</p><p>Числовой не может использовать дедупликацию. Масштаб числового отображения должен быть сохранен среди равных дат.</p><p>jsonb не может использовать дедупликацию, поскольку класс операторов JSONB B-Tree использует внутренние числовые данные.</p><p>float4 и float8 не могут использовать дедупликацию. Эти типы имеют различные представления для -0 и 0, которые, тем не менее, считаются равными. Это различие должно быть сохранено.</p><p>Существует еще одно ограничение на уровне реализации, которое может быть снято в будущей версии PostgreSQL:</p><p>Типы контейнеров (такие как составные типы, массивы или диапазонные типы) не могут использовать дедупликацию.</p><p>Существует еще одно ограничение на уровне реализации, которое применяется независимо от класса оператора или используемого сопоставления:</p><p>Индексы INCLUDE никогда не могут использовать дедупликацию.</p>

<h2>64.2. GiST Indexes #</h2>
<p>GiST означает Generalized Search Tree (Обобщенное дерево поиска). Это сбалансированный, древовидный метод доступа, который действует как базовый шаблон для реализации произвольных схем индексации. B-деревья, R-деревья и многие другие схемы индексации могут быть реализованы в GiST.</p><p>Одним из преимуществ GiST является то, что он позволяет разрабатывать пользовательские типы данных с соответствующими методами доступа эксперту в области типа данных, а не эксперту по базам данных.</p><p>Часть информации здесь взята с веб-сайта проекта индексирования GiST Калифорнийского университета в Беркли и диссертации Марселя Корнакера «Методы доступа для систем баз данных следующего поколения». Реализацию GiST в PostgreSQL в основном поддерживают Теодор Сигаев и Олег Бартунов, и на их веб-сайте есть дополнительная информация.</p><p>Основной дистрибутив PostgreSQL включает классы операторов GiST, показанные в Таблице 64.1. (Некоторые из дополнительных модулей, описанных в Приложении F, предоставляют дополнительные классы операторов GiST.)</p><p>Таблица 64.1. Встроенные классы операторов GiST</p><p>По историческим причинам класс оператора inet_ops не является классом по умолчанию для типов inet и cidr. Чтобы использовать его, укажите имя класса в CREATE INDEX, например</p><p>Традиционно реализация нового метода доступа индекса означала много сложной работы. Необходимо было понять внутреннюю работу базы данных, такую ​​как менеджер блокировок и журнал упреждающей записи. Интерфейс GiST имеет высокий уровень абстракции, требуя от реализатора метода доступа только реализации семантики типа данных, к которым осуществляется доступ. Сам слой GiST заботится о параллелизме, ведении журнала и поиске в древовидной структуре.</p><p>Эту расширяемость не следует путать с расширяемостью других стандартных деревьев поиска с точки зрения данных, которые они могут обрабатывать. Например, PostgreSQL поддерживает расширяемые B-деревья и хэш-индексы. Это означает, что вы можете использовать PostgreSQL для построения B-дерева или хеша по любому типу данных, который вам нужен. Но B-деревья поддерживают только предикаты диапазона (<, =, >), а хэш-индексы поддерживают только запросы равенства.</p><p>Так что если вы индексируете, скажем, коллекцию изображений с помощью B-дерева PostgreSQL, вы можете выдавать только такие запросы, как «равно ли imagex imagey», «меньше ли imagex imagey» и «больше ли imagex imagey». В зависимости от того, как вы определяете «равно», «меньше» и «больше» в этом контексте, это может быть полезно. Однако, используя индекс на основе GiST, вы можете создать способы задавать вопросы, специфичные для предметной области, например, «найти все изображения лошадей» или «найти все переэкспонированные изображения».</p><p>Все, что нужно для запуска метода доступа GiST, — это реализовать несколько пользовательских методов, которые определяют поведение ключей в дереве. Конечно, эти методы должны быть довольно замысловатыми, чтобы поддерживать замысловатые запросы, но для всех стандартных запросов (B-деревья, R-деревья и т. д.) они относительно просты. Короче говоря, GiST сочетает в себе расширяемость с универсальностью, повторное использование кода и чистый интерфейс.</p><p>Класс оператора индекса для GiST должен предоставлять пять методов, а шесть являются необязательными. Корректность индекса обеспечивается правильной реализацией тех же самых, последовательных и объединенных методов, в то время как эффективность (размер и скорость) индекса будет зависеть от методов штрафа и picksplit. Два необязательных метода — это сжатие и распаковка, которые позволяют индексу иметь внутренние данные дерева другого типа, чем данные, которые он индексирует. Листья должны иметь индексированный тип данных, в то время как другие узлы дерева могут иметь любую структуру C (но вам все равно придется следовать правилам типов данных PostgreSQL здесь, см. о varlena для данных переменного размера). Если внутренний тип данных дерева существует на уровне SQL, можно использовать опцию STORAGE команды CREATE OPERATOR CLASS. Необязательный восьмой метод — это расстояние, которое необходимо, если класс оператора хочет поддерживать упорядоченные сканирования (поиск ближайшего соседа). Необязательный девятый метод fetch необходим, если класс оператора хочет поддерживать сканирование только индекса, за исключением случаев, когда метод compress опущен. Необязательный десятый метод options необходим, если класс оператора имеет заданные пользователем параметры. Необязательный одиннадцатый метод sortsupport используется для ускорения построения индекса GiST.</p><p>При наличии записи индекса p и значения запроса q эта функция определяет, является ли запись индекса «согласованной» с запросом; то есть может ли предикат «indexed_column indexable_operator q» быть истинным для любой строки, представленной записью индекса? Для записи индекса листа это эквивалентно проверке условия индексируемости, в то время как для внутреннего узла дерева это определяет, необходимо ли сканировать поддерево индекса, представленного узлом дерева. Когда результат истинен, также должен быть возвращен флаг повторной проверки. Это указывает, является ли предикат определенно истинным или только возможно истинным. Если recheck = false, то индекс точно проверил условие предиката, тогда как если recheck = true, то строка является только кандидатом на совпадение. В этом случае система автоматически оценит indexable_operator по фактическому значению строки, чтобы увидеть, действительно ли это совпадение. Это соглашение позволяет GiST поддерживать как без потерь, так и с потерями структуры индекса.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Здесь key — это элемент в индексе, а query — значение, искомое в индексе. Параметр StrategyNumber указывает, какой оператор вашего класса операторов применяется — он соответствует одному из номеров операторов в команде CREATE OPERATOR CLASS.</p><p>В зависимости от того, какие операторы вы включили в класс, тип данных запроса может меняться в зависимости от оператора, поскольку это будет любой тип, указанный справа от оператора, который может отличаться от индексированного типа данных, указанного слева. (Приведенный выше скелет кода предполагает, что возможен только один тип; в противном случае извлечение значения аргумента запроса должно зависеть от оператора.) Рекомендуется, чтобы в объявлении SQL согласованной функции использовался индексированный тип данных opclass для аргумента запроса, даже если фактический тип может быть другим в зависимости от оператора.</p><p>Этот метод объединяет информацию в дереве. При наличии набора записей эта функция генерирует новую запись индекса, которая представляет все заданные записи.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Как вы можете видеть, в этом скелете мы имеем дело с типом данных, где union(X, Y, Z) = union(union(X, Y), Z). Достаточно легко поддерживать типы данных, где это не так, реализовав правильный алгоритм union в этом методе поддержки GiST.</p><p>Результатом функции union должно быть значение типа хранения индекса, каким бы он ни был (он может отличаться или не отличаться от типа индексированного столбца). Функция union должна возвращать указатель на недавно выделенную palloc() память. Вы не можете просто вернуть входное значение как есть, даже если тип не был изменен.</p><p>Как показано выше, первый внутренний аргумент функции union на самом деле является указателем GistEntryVector. Второй аргумент — указатель на целочисленную переменную, которую можно игнорировать. (Раньше требовалось, чтобы функция union сохраняла размер своего результирующего значения в этой переменной, но теперь это не обязательно.)</p><p>Преобразует элемент данных в формат, подходящий для физического хранения на странице индекса. Если метод сжатия опущен, элементы данных сохраняются в индексе без изменений.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Конечно, вам придется адаптировать compress_data_type к конкретному типу, в который вы преобразуете, чтобы сжать ваши конечные узлы.</p><p>Преобразует сохраненное представление элемента данных в формат, который может быть обработан другими методами GiST в классе операторов. Если метод decompress опущен, предполагается, что другие методы GiST могут работать напрямую с сохраненным форматом данных. (decompress не обязательно является обратным методу compress; в частности, если compress с потерями, то decompress не может точно восстановить исходные данные. decompress также не обязательно эквивалентен fetch, поскольку другие методы GiST могут не требовать полной реконструкции данных.)</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Приведенный выше скелет подходит для случая, когда декомпрессия не требуется. (Но, конечно, вообще отказаться от этого метода еще проще, и это рекомендуется в таких случаях.)</p><p>Возвращает значение, указывающее «стоимость» вставки новой записи в определенную ветвь дерева. Элементы будут вставлены по пути наименьшего штрафа в дереве. Значения, возвращаемые штрафом, должны быть неотрицательными. Если возвращается отрицательное значение, оно будет рассматриваться как ноль.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>По историческим причинам функция штрафа не просто возвращает результат с плавающей точкой; вместо этого она должна сохранить значение в месте, указанном третьим аргументом. Возвращаемое значение как таковое игнорируется, хотя принято передавать обратно адрес этого аргумента.</p><p>Функция штрафа имеет решающее значение для хорошей производительности индекса. Она будет использоваться во время вставки, чтобы определить, какой ветви следовать при выборе места добавления новой записи в дерево. Во время запроса, чем более сбалансирован индекс, тем быстрее поиск.</p><p>Когда необходимо разделить страницу индекса, эта функция решает, какие записи на странице останутся на старой странице, а какие будут перенесены на новую страницу.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Обратите внимание, что результат функции picksplit доставляется путем изменения переданной структуры v. Возвращаемое значение как таковое игнорируется, хотя принято передавать обратно адрес v.</p><p>Как и штраф, функция picksplit имеет решающее значение для хорошей производительности индекса. Разработка подходящих реализаций штрафа и picksplit — вот где заключается проблема внедрения хорошо работающих индексов GiST.</p><p>Возвращает значение true, если две записи индекса идентичны, в противном случае — false. («Запись индекса» — это значение типа хранения индекса, а не обязательно тип исходного индексированного столбца.)</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>По историческим причинам та же функция не просто возвращает логический результат; вместо этого она должна сохранить флаг в месте, указанном третьим аргументом. Возвращаемое значение как таковое игнорируется, хотя принято передавать обратно адрес этого аргумента.</p><p>При наличии записи индекса p и значения запроса q эта функция определяет «расстояние» записи индекса от значения запроса. Эта функция должна быть предоставлена, если класс операторов содержит какие-либо операторы упорядочивания. Запрос с использованием оператора упорядочивания будет реализован путем возврата записей индекса с наименьшими значениями «расстояния» в первую очередь, поэтому результаты должны соответствовать семантике оператора. Для записи индекса листа результат просто представляет расстояние до записи индекса; для внутреннего узла дерева результат должен быть наименьшим расстоянием, которое может иметь любая дочерняя запись.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>И соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Аргументы функции расстояния идентичны аргументам согласованной функции.</p><p>При определении расстояния допускается некоторое приближение, при условии, что результат никогда не будет больше фактического расстояния записи. Так, например, расстояния до ограничивающего прямоугольника обычно достаточно в геометрических приложениях. Для внутреннего узла дерева возвращаемое расстояние не должно быть больше расстояния до любого из дочерних узлов. Если возвращаемое расстояние не является точным, функция должна установить *recheck в значение true. (Это не обязательно для внутренних узлов дерева; для них вычисление всегда предполагается неточным.) В этом случае исполнитель вычислит точное расстояние после извлечения кортежа из кучи и при необходимости переупорядочит кортежи.</p><p>Если функция расстояния возвращает *recheck = true для любого листового узла, тип возврата исходного оператора упорядочивания должен быть float8 или float4, а значения результата функции расстояния должны быть сопоставимы со значениями исходного оператора упорядочивания, поскольку исполнитель будет сортировать, используя как результаты функции расстояния, так и пересчитанные результаты оператора упорядочивания. В противном случае значения результата функции расстояния могут быть любыми конечными значениями float8, пока относительный порядок значений результата соответствует порядку, возвращаемому оператором упорядочивания. (Бесконечность и минус бесконечность используются внутренне для обработки таких случаев, как null, поэтому не рекомендуется, чтобы функции расстояния возвращали эти значения.)</p><p>Преобразует сжатое индексное представление элемента данных в исходный тип данных для сканирования только индекса. Возвращаемые данные должны быть точной копией без потерь исходного индексированного значения.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Аргумент — указатель на структуру GISTENTRY. При входе ее ключевое поле содержит непустые листовые данные в сжатой форме. Возвращаемое значение — другая структура GISTENTRY, ключевое поле которой содержит те же данные в исходной, несжатой форме. Если функция сжатия класса операций ничего не делает для листовых записей, метод выборки может вернуть аргумент как есть. Или, если класс операций не имеет функции сжатия, метод выборки также можно опустить, поскольку он обязательно будет пустым.</p><p>Соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Если метод сжатия приводит к потерям для конечных записей, класс оператора не может поддерживать сканирование только индекса и не должен определять функцию выборки.</p><p>Позволяет определять видимые пользователю параметры, которые управляют поведением класса оператора.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Функция передает указатель на структуру local_relopts, которую необходимо заполнить набором опций, специфичных для класса оператора. Доступ к опциям можно получить из других функций поддержки с помощью макросов PG_HAS_OPCLASS_OPTIONS() и PG_GET_OPCLASS_OPTIONS().</p><p>Ниже приведен пример реализации my_options() и использования параметров из других вспомогательных функций:</p><p>Поскольку представление ключа в GiST является гибким, оно может зависеть от указанных пользователем параметров. Например, может быть указана длина подписи ключа. См., например, gtsvector_options().</p><p>Возвращает функцию-компаратор для сортировки данных способом, сохраняющим локальность. Используется командами CREATE INDEX и REINDEX. Качество созданного индекса зависит от того, насколько хорошо порядок сортировки, определенный функцией-компаратором, сохраняет локальность входных данных.</p><p>Метод sortsupport необязателен. Если он не указан, CREATE INDEX строит индекс, вставляя каждый кортеж в дерево с использованием функций штрафа и picksplit, что намного медленнее.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Аргумент — указатель на структуру SortSupport. Как минимум, функция должна заполнить поле своего компаратора. Компаратор принимает три аргумента: два Datum для сравнения и указатель на структуру SortSupport. Datums — это два индексированных значения в том формате, в котором они хранятся в индексе; то есть в формате, возвращаемом методом compress. Полный API определен в src/include/utils/sortsupport.h.</p><p>Соответствующий код в модуле C мог бы тогда следовать этому скелету:</p><p>Все методы поддержки GiST обычно вызываются в краткосрочных контекстах памяти; то есть CurrentMemoryContext будет сбрасываться после обработки каждого кортежа. Поэтому не так уж важно беспокоиться о pfree'е всего, что вы palloc. Однако в некоторых случаях для метода поддержки полезно кэшировать данные между повторяющимися вызовами. Для этого выделите долгоживущие данные в fcinfo->flinfo->fn_mcxt и сохраните указатель на них в fcinfo->flinfo->fn_extra. Такие данные сохранятся в течение всего срока действия операции индексирования (например, одного сканирования индекса GiST, построения индекса или вставки кортежа индекса). Будьте осторожны, чтобы pfree предыдущего значения при замене значения fn_extra, иначе утечка будет накапливаться в течение всей операции.</p><p>Самый простой способ построить индекс GiST — просто вставить все записи одну за другой. Это обычно медленно для больших индексов, поскольку если кортежи индекса разбросаны по индексу, а индекс достаточно большой, чтобы не поместиться в кэш, потребуется много случайных операций ввода-вывода. PostgreSQL поддерживает два альтернативных метода для первоначального построения индекса GiST: сортированный и буферизованный режимы.</p><p>Метод sorted доступен только в том случае, если каждый из используемых индексом классов операций предоставляет функцию sortsupport, как описано в разделе 64.2.3. Если это так, этот метод обычно является лучшим, поэтому он используется по умолчанию.</p><p>Буферизованный метод работает, не вставляя кортежи непосредственно в индекс сразу. Он может значительно сократить количество случайных операций ввода-вывода, необходимых для неупорядоченных наборов данных. Для хорошо упорядоченных наборов данных преимущество меньше или отсутствует, поскольку только небольшое количество страниц получают новые кортежи за раз, и эти страницы помещаются в кэш, даже если индекс в целом не помещается.</p><p>Буферизованный метод должен вызывать функцию штрафа чаще, чем простой метод, что потребляет некоторые дополнительные ресурсы ЦП. Кроме того, буферам требуется временное дисковое пространство, вплоть до размера результирующего индекса. Буферизация также может влиять на качество результирующего индекса как в положительном, так и в отрицательном направлении. Это влияние зависит от различных факторов, таких как распределение входных данных и реализация класса оператора.</p><p>Если сортировка невозможна, то по умолчанию построение индекса GiST переключается на метод буферизации, когда размер индекса достигает effective_cache_size. Буферизацию можно вручную принудительно включить или предотвратить с помощью параметра буферизации в команде CREATE INDEX. Поведение по умолчанию подходит для большинства случаев, но отключение буферизации может несколько ускорить построение, если входные данные упорядочены.</p><p>Исходный дистрибутив PostgreSQL включает несколько примеров методов индексирования, реализованных с использованием GiST. В настоящее время основная система обеспечивает поддержку текстового поиска (индексирование для tsvector и tsquery), а также эквивалентную функциональность R-Tree для некоторых встроенных геометрических типов данных (см. src/backend/access/gist/gistproc.c). Следующие contrib-модули также содержат классы операторов GiST:</p><p>Эквивалентная функциональность B-дерева для нескольких типов данных</p><p>Индексация для многомерных кубов</p><p>Модуль для хранения пар (ключ, значение)</p><p>RD-Tree для одномерного массива значений int4</p><p>Индексация для древовидных структур</p><p>Сходство текста с использованием сопоставления триграмм</p><p>Индексация для «плавающих диапазонов»</p>

<h2>64.3. SP-GiST Indexes #</h2>
<p>SP-GiST — это аббревиатура для пространственно-разделенного GiST. SP-GiST поддерживает разделенные деревья поиска, которые облегчают разработку широкого спектра различных несбалансированных структур данных, таких как квадродеревья, деревья k-d и радиксные деревья (tries). Общей чертой этих структур является то, что они многократно делят пространство поиска на разделы, которые не обязательно должны быть одинакового размера. Поиски, которые хорошо соответствуют правилу разбиения, могут быть очень быстрыми.</p><p>Эти популярные структуры данных изначально были разработаны для использования в памяти. В основной памяти они обычно проектируются как набор динамически выделяемых узлов, связанных указателями. Это не подходит для прямого хранения на диске, поскольку эти цепочки указателей могут быть довольно длинными, что потребует слишком много обращений к диску. Напротив, дисковые структуры данных должны иметь высокую степень разветвления, чтобы минимизировать ввод-вывод. Задача, решаемая SP-GiST, заключается в сопоставлении узлов дерева поиска со страницами диска таким образом, чтобы поиску требовался доступ только к нескольким страницам диска, даже если он проходит по многим узлам.</p><p>Как и GiST, SP-GiST предназначен для разработки пользовательских типов данных с соответствующими методами доступа экспертом в области типа данных, а не экспертом по базам данных.</p><p>Часть информации здесь взята с веб-сайта проекта индексирования SP-GiST Университета Пердью. Реализацию SP-GiST в PostgreSQL в основном поддерживают Теодор Сигаев и Олег Бартунов, и на их веб-сайте есть дополнительная информация.</p><p>Основной дистрибутив PostgreSQL включает классы операторов SP-GiST, показанные в таблице 64.2.</p><p>Таблица 64.2. Встроенные классы операторов SP-GiST</p><p>Из двух классов операторов для типа point quad_point_ops является классом по умолчанию. kd_point_ops поддерживает те же операторы, но использует другую структуру данных индекса, которая может обеспечивать лучшую производительность в некоторых приложениях.</p><p>Классы операторов quad_point_ops, kd_point_ops и poly_ops поддерживают оператор упорядочения <->, который позволяет выполнять поиск по методу k-ближайших соседей (k-NN) по индексированным наборам данных точек или полигонов.</p><p>SP-GiST предлагает интерфейс с высоким уровнем абстракции, требующий от разработчика метода доступа реализовывать только методы, специфичные для данного типа данных. Ядро SP-GiST отвечает за эффективное отображение диска и поиск в древовидной структуре. Оно также заботится о параллелизме и логировании.</p><p>Листовые кортежи дерева SP-GiST обычно содержат значения того же типа данных, что и индексированный столбец, хотя они также могут содержать неточные представления индексированного столбца. Листовые кортежи, хранящиеся на корневом уровне, будут напрямую представлять исходное индексированное значение данных, но листовые кортежи на более низких уровнях могут содержать только частичное значение, например суффикс. В этом случае функции поддержки класса операторов должны иметь возможность реконструировать исходное значение, используя информацию, накопленную из внутренних кортежей, которые передаются для достижения листового уровня.</p><p>Когда индекс SP-GiST создается с помощью столбцов INCLUDE, значения этих столбцов также сохраняются в конечных кортежах. Столбцы INCLUDE не имеют отношения к классу операторов SP-GiST, поэтому они здесь далее не обсуждаются.</p><p>Внутренние кортежи более сложны, так как они являются точками ветвления в дереве поиска. Каждый внутренний кортеж содержит набор из одного или нескольких узлов, которые представляют группы схожих конечных значений. Узел содержит нисходящую ссылку, которая ведет либо к другому, более низкоуровневому внутреннему кортежу, либо к короткому списку конечных кортежей, которые все лежат на одной странице индекса. Каждый узел обычно имеет метку, которая его описывает; например, в радиксном дереве метка узла может быть следующим символом строкового значения. (В качестве альтернативы класс оператора может опустить метки узлов, если он работает с фиксированным набором узлов для всех внутренних кортежей; см. Раздел 64.3.4.2.) При желании внутренний кортеж может иметь значение префикса, которое описывает всех его членов. В радиксном дереве это может быть общий префикс представленных строк. Значение префикса не обязательно является настоящим префиксом, но может быть любыми данными, необходимыми классу оператора; например, в квадродереве он может хранить центральную точку, относительно которой измеряются четыре квадранта. Внутренний кортеж квадродерева тогда также будет содержать четыре узла, соответствующие квадрантам вокруг этой центральной точки.</p><p>Некоторые алгоритмы деревьев требуют знания уровня (или глубины) текущего кортежа, поэтому ядро ​​SP-GiST предоставляет возможность классам операторов управлять подсчетом уровней при спуске по дереву. Также есть поддержка для инкрементальной реконструкции представленного значения, когда это необходимо, и для передачи дополнительных данных (называемых значениями траверса) во время спуска по дереву.</p><p>Основной код SP-GiST обрабатывает записи null. Хотя индексы SP-GiST действительно хранят записи для null в индексированных столбцах, это скрыто от кода класса оператора индекса: никакие записи индекса null или условия поиска никогда не будут переданы методам класса оператора. (Предполагается, что операторы SP-GiST являются строгими и поэтому не могут успешно обрабатывать значения null.) Поэтому значения null здесь далее не обсуждаются.</p><p>Существует пять пользовательских методов, которые класс оператора индекса для SP-GiST должен предоставлять, и два из них являются необязательными. Все пять обязательных методов следуют соглашению о принятии двух внутренних аргументов, первый из которых является указателем на структуру C, содержащую входные значения для метода поддержки, в то время как второй аргумент является указателем на структуру C, куда должны быть помещены выходные значения. Четыре обязательных метода просто возвращают void, поскольку все их результаты появляются в выходной структуре; но leaf_consistent возвращает логический результат. Методы не должны изменять никакие поля своих входных структур. Во всех случаях выходная структура инициализируется нулями перед вызовом пользовательского метода. Необязательный шестой метод compress принимает данные для индексации в качестве единственного аргумента и возвращает значение, подходящее для физического хранения в листовом кортеже. Необязательный седьмой метод options принимает внутренний указатель на структуру C, куда должны быть помещены параметры, специфичные для opclass, и возвращает void.</p><p>Пять обязательных пользовательских методов:</p><p>Возвращает статическую информацию о реализации индекса, включая OID типов данных префикса и типов данных метки узла.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgConfigIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgConfigOut C, которую функция должна заполнить данными результата.</p><p>attType передается для поддержки полиморфных классов операторов индекса; для обычных классов операторов с фиксированным типом данных он всегда будет иметь одно и то же значение и поэтому может быть проигнорирован.</p><p>Для классов операторов, не использующих префиксы, prefixType может быть установлен в VOIDOID. Аналогично, для классов операторов, не использующих метки узлов, labelType может быть установлен в VOIDOID. canReturnData следует установить в true, если класс операторов способен восстановить изначально предоставленное значение индекса. longValuesOK следует установить в true, только если attType имеет переменную длину, а класс операторов способен сегментировать длинные значения путем повторного суффиксирования (см. раздел 64.3.4.1).</p><p>leafType должен соответствовать типу хранилища индекса, определенному записью каталога opckeytype класса оператора. (Обратите внимание, что opckeytype может быть равен нулю, подразумевая, что тип хранилища совпадает с типом ввода класса оператора, что является наиболее распространенной ситуацией.) Из соображений обратной совместимости метод config может установить leafType в какое-либо другое значение, и это значение будет использоваться; но это устарело, поскольку содержимое индекса затем неправильно идентифицируется в каталогах. Кроме того, допустимо оставить leafType неинициализированным (нулем); это интерпретируется как означающее тип хранилища индекса, полученный из opckeytype.</p><p>Если attType и leafType различны, необходимо предоставить необязательный метод compress. Метод compress отвечает за преобразование индексируемых данных из attType в leafType.</p><p>Выбирает метод вставки нового значения во внутренний кортеж.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgChooseIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgChooseOut C, которую функция должна заполнить данными результата.</p><p>datum — исходный datum типа spgConfigIn.attType, который должен был быть вставлен в индекс. leafDatum — значение типа spgConfigOut.leafType, которое изначально является результатом метода compress, примененного к datum, когда метод compress предоставляется, или тем же значением, что и datum в противном случае. leafDatum может изменяться на более низких уровнях дерева, если методы choose или picksplit изменяют его. Когда поиск вставки достигает листовой страницы, текущее значение leafDatum — это то, что будет сохранено во вновь созданном листовом кортеже. level — текущий уровень внутреннего кортежа, начиная с нуля для корневого уровня. allTheSame имеет значение true, если текущий внутренний кортеж помечен как содержащий несколько эквивалентных узлов (см. раздел 64.3.4.3). hasPrefix имеет значение true, если текущий внутренний кортеж содержит префикс; если это так, prefixDatum является его значением. nNodes — это количество дочерних узлов, содержащихся во внутреннем кортеже, а nodeLabels — это массив значений их меток или NULL, если меток нет.</p><p>Функция выбора может определить, что новое значение соответствует одному из существующих дочерних узлов, или что необходимо добавить новый дочерний узел, или что новое значение не соответствует префиксу кортежа, и поэтому внутренний кортеж необходимо разделить, чтобы создать менее ограничительный префикс.</p><p>Если новое значение совпадает с одним из существующих дочерних узлов, установите resultType на spgMatchNode. Установите nodeN на индекс (от нуля) этого узла в массиве узлов. Установите levelAdd на приращение уровня, вызванное спуском через этот узел, или оставьте его равным нулю, если класс оператора не использует уровни. Установите restDatum на значение leafDatum, если класс оператора не изменяет datums с одного уровня на другой, или в противном случае установите его на измененное значение, которое будет использоваться как leafDatum на следующем уровне.</p><p>Если необходимо добавить новый дочерний узел, установите resultType на spgAddNode. Установите nodeLabel на метку, которая будет использоваться для нового узла, и установите nodeN на индекс (от нуля), по которому следует вставить узел в массив узлов. После добавления узла функция select будет вызвана снова с измененным внутренним кортежем; этот вызов должен привести к результату spgMatchNode.</p><p>Если новое значение не соответствует префиксу кортежа, установите resultType на spgSplitTuple. Это действие перемещает все существующие узлы в новый внутренний кортеж нижнего уровня и заменяет существующий внутренний кортеж кортежем с одной нисходящей линией, указывающей на новый внутренний кортеж нижнего уровня. Установите prefixHasPrefix, чтобы указать, должен ли новый верхний кортеж иметь префикс, и если да, установите prefixPrefixDatum на значение префикса. Это новое значение префикса должно быть достаточно менее ограничивающим, чем исходное, чтобы принять новое значение для индексации. Установите prefixNNodes на количество узлов, необходимых в новом кортеже, и установите prefixNodeLabels на palloc'd массив, содержащий их метки, или на NULL, если метки узлов не требуются. Обратите внимание, что общий размер нового верхнего кортежа не должен превышать общий размер заменяемого им кортежа; это ограничивает длину нового префикса и новых меток. Установите childNodeN на индекс (от нуля) узла, который будет нисходить к новому внутреннему кортежу нижнего уровня. Установите postfixHasPrefix, чтобы указать, должен ли новый внутренний кортеж нижнего уровня иметь префикс, и если да, установите postfixPrefixDatum на значение префикса. Комбинация этих двух префиксов и метка нисходящего узла (если есть) должны иметь то же значение, что и исходный префикс, поскольку нет возможности изменить метки узлов, которые перемещаются в новый кортеж нижнего уровня, или изменить какие-либо записи дочернего индекса. После разделения узла функция choose будет вызвана снова с заменяющим внутренним кортежем. Этот вызов может вернуть результат spgAddNode, если действие spgSplitTuple не создало подходящего узла. В конечном итоге choose должен вернуть spgMatchNode, чтобы позволить вставке спуститься на следующий уровень.</p><p>Решает, как создать новый внутренний кортеж из набора конечных кортежей.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgPickSplitIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgPickSplitOut C, которую функция должна заполнить данными результата.</p><p>nTuples — это количество предоставленных конечных кортежей. datums — это массив их значений datum типа spgConfigOut.leafType. level — это текущий уровень, который разделяют все конечные кортежи, который станет уровнем нового внутреннего кортежа.</p><p>Установите hasPrefix, чтобы указать, должен ли новый внутренний кортеж иметь префикс, и если да, установите prefixDatum в значение префикса. Установите nNodes, чтобы указать количество узлов, которые будет содержать новый внутренний кортеж, и установите nodeLabels в массив их значений меток или в NULL, если метки узлов не требуются. Установите mapTuplesToNodes в массив, который дает индекс (от нуля) узла, которому должен быть назначен каждый листовой кортеж. Установите leafTupleDatums в массив значений, которые будут храниться в новых листовых кортежах (они будут такими же, как входные данные, если класс оператора не изменяет данные с одного уровня на другой). Обратите внимание, что функция picksplit отвечает за palloc'ing массивов nodeLabels, mapTuplesToNodes и leafTupleDatums.</p><p>Если указано более одного кортежа листьев, ожидается, что функция picksplit классифицирует их в более чем один узел; в противном случае невозможно разделить кортежи листьев по нескольким страницам, что является конечной целью этой операции. Поэтому, если функция picksplit в конечном итоге поместит все кортежи листьев в один и тот же узел, основной код SP-GiST переопределит это решение и сгенерирует внутренний кортеж, в котором кортежи листьев будут назначены случайным образом нескольким одинаково помеченным узлам. Такой кортеж помечается как allTheSame, чтобы обозначить, что это произошло. Функции choose и inner_consistent должны проявлять соответствующую осторожность с такими внутренними кортежами. Для получения дополнительной информации см. раздел 64.3.4.3.</p><p>picksplit можно применить к одному листовому кортежу только в том случае, если функция config установила longValuesOK в значение true и было предоставлено входное значение, превышающее страницу. В этом случае смысл операции заключается в удалении префикса и создании нового, более короткого листового значения данных. Вызов будет повторяться до тех пор, пока не будет создан листовой элемент данных, достаточно короткий для размещения на странице. Для получения дополнительной информации см. раздел 64.3.4.1.</p><p>Возвращает набор узлов (ветвей), которые необходимо отслеживать при поиске по дереву.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgInnerConsistentIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgInnerConsistentOut C, которую функция должна заполнить данными результата.</p><p>Массив scankeys длиной nkeys описывает условие(я) поиска индекса. Эти условия объединяются с помощью AND — интересны только записи индекса, которые удовлетворяют всем им. (Обратите внимание, что nkeys = 0 подразумевает, что все записи индекса удовлетворяют запросу.) Обычно функция conformity заботится только о полях sk_strategy и sk_argument каждой записи массива, которые соответственно дают индексируемый оператор и значение сравнения. В частности, нет необходимости проверять sk_flags, чтобы увидеть, является ли значение сравнения NULL, поскольку основной код SP-GiST отфильтрует такие условия. Массив orderbys длиной norderbys описывает операторы упорядочивания (если таковые имеются) таким же образом. reformedValue — это значение, восстановленное для родительского кортежа; оно равно (Datum) 0 на корневом уровне или если функция inner_consistent не предоставила значение на родительском уровне. traversalValue — указатель на любые данные траверса, переданные из предыдущего вызова inner_consistent в родительском индексном кортеже, или NULL на корневом уровне. traversalMemoryContext — контекст памяти, в котором хранятся выходные значения траверса (см. ниже). level — текущий уровень внутреннего кортежа, начинающийся с нуля для корневого уровня. returnData — true, если для этого запроса требуются восстановленные данные; это будет так, только если функция конфигурации заявила canReturnData. allTheSame — true, если текущий внутренний кортеж помечен как «все то же самое»; в этом случае все узлы имеют одинаковую метку (если таковая имеется), и поэтому либо все, либо ни один из них не соответствуют запросу (см. раздел 64.3.4.3). hasPrefix — true, если текущий внутренний кортеж содержит префикс; если это так, prefixDatum — его значение. nNodes — это количество дочерних узлов, содержащихся во внутреннем кортеже, а nodeLabels — это массив значений их меток или NULL, если у узлов нет меток.</p><p>nNodes должен быть установлен на количество дочерних узлов, которые необходимо посетить при поиске, а nodeNumbers должен быть установлен на массив их индексов. Если класс оператора отслеживает уровни, установите levelAdds на массив приращений уровня, необходимых при спуске к каждому посещаемому узлу. (Часто эти приращения будут одинаковыми для всех узлов, но это не обязательно так, поэтому используется массив.) Если требуется реконструкция значений, установите reformedValues ​​на массив значений, реконструированных для каждого посещаемого дочернего узла; в противном случае оставьте reformedValues ​​как NULL. Предполагается, что реконструированные значения имеют тип spgConfigOut.leafType. (Однако, поскольку основная система ничего не будет с ними делать, кроме как, возможно, скопирует их, достаточно, чтобы они имели те же свойства typlen и typbyval, что и leafType.) Если выполняется упорядоченный поиск, установите distances на массив значений расстояний в соответствии с массивом orderbys (узлы с наименьшими расстояниями будут обработаны первыми). В противном случае оставьте NULL. Если требуется передать дополнительную внеполосную информацию («значения траверса») на нижние уровни поиска по дереву, установите traversalValues ​​в массив соответствующих значений траверса, по одному для каждого дочернего узла, который нужно посетить; в противном случае оставьте traversalValues ​​как NULL. Обратите внимание, что функция inner_consistent отвечает за palloc'ing массивов nodeNumbers, levelAdds, distances, reformedValues ​​и traversalValues ​​в текущем контексте памяти. Однако любые выходные значения траверса, на которые указывает массив traversalValues, должны быть выделены в traversalMemoryContext. Каждое значение траверса должно быть отдельным palloc'ed chunk.</p><p>Возвращает значение true, если конечный кортеж удовлетворяет запросу.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Первый аргумент — указатель на структуру spgLeafConsistentIn C, содержащую входные данные для функции. Второй аргумент — указатель на структуру spgLeafConsistentOut C, которую функция должна заполнить данными результата.</p><p>Массив scankeys длиной nkeys описывает условие(я) поиска индекса. Эти условия объединяются с помощью AND — только записи индекса, которые удовлетворяют всем им, удовлетворяют запросу. (Обратите внимание, что nkeys = 0 подразумевает, что все записи индекса удовлетворяют запросу.) Обычно функция conformity заботится только о полях sk_strategy и sk_argument каждой записи массива, которые соответственно дают индексируемый оператор и значение сравнения. В частности, нет необходимости проверять sk_flags, чтобы увидеть, является ли значение сравнения NULL, поскольку основной код SP-GiST отфильтрует такие условия. Массив orderbys длиной norderbys описывает операторы упорядочивания таким же образом. reformedValue — это значение, восстановленное для родительского кортежа; оно равно (Datum) 0 на корневом уровне или если функция inner_consistent не предоставила значение на родительском уровне. traversalValue — указатель на любые данные траверса, переданные из предыдущего вызова inner_consistent в родительском кортеже индекса, или NULL на корневом уровне. level — уровень текущего листового кортежа, начинающийся с нуля для корневого уровня. returnData имеет значение true, если для этого запроса требуются реконструированные данные; это будет так, только если функция конфигурации подтвердила canReturnData. leafDatum — ключевое значение spgConfigOut.leafType, хранящееся в текущем листовом кортеже.</p><p>Функция должна возвращать true, если конечный кортеж соответствует запросу, или false, если нет. В случае true, если returnData имеет значение true, то leafValue должно быть установлено на значение (типа spgConfigIn.attType), изначально предоставленное для индексации для этого конечного кортежа. Кроме того, recheck может быть установлено на true, если соответствие неопределенное, и поэтому оператор(ы) должны быть повторно применены к фактическому кортежу кучи для проверки соответствия. Если выполняется упорядоченный поиск, установите расстояния в массив значений расстояний в соответствии с массивом orderbys. В противном случае оставьте его NULL. Если хотя бы одно из возвращенных расстояний не является точным, установите recheckDistances на true. В этом случае исполнитель вычислит точные расстояния после извлечения кортежа из кучи и при необходимости переупорядочит кортежи.</p><p>Необязательные определяемые пользователем методы:</p><p>Преобразует элемент данных в формат, подходящий для физического хранения в листовом кортеже индекса. Принимает значение типа spgConfigIn.attType и возвращает значение типа spgConfigOut.leafType. Выходное значение не должно содержать внешний указатель TOAST.</p><p>Примечание: метод сжатия применяется только к значениям, которые необходимо сохранить. Последовательные методы получают ключи сканирования запросов без изменений, без преобразования с помощью сжатия.</p><p>Определяет набор видимых пользователю параметров, которые управляют поведением класса оператора.</p><p>SQL-декларация функции должна выглядеть следующим образом:</p><p>Функция передает указатель на структуру local_relopts, которую необходимо заполнить набором опций, специфичных для класса оператора. Доступ к опциям можно получить из других функций поддержки с помощью макросов PG_HAS_OPCLASS_OPTIONS() и PG_GET_OPCLASS_OPTIONS().</p><p>Поскольку представление ключа в SP-GiST является гибким, оно может зависеть от указанных пользователем параметров.</p><p>Все методы поддержки SP-GiST обычно вызываются в кратковременном контексте памяти; то есть CurrentMemoryContext будет сброшен после обработки каждого кортежа. Поэтому не так уж важно беспокоиться о pfree'е всего, что вы palloc. (Метод config является исключением: он должен попытаться избежать утечки памяти. Но обычно метод config не должен ничего делать, кроме как назначать константы в переданную структуру параметров.)</p><p>Если индексированный столбец имеет тип данных, поддающийся сортировке, сортировка индекса будет передана всем методам поддержки с использованием стандартного механизма PG_GET_COLLATION().</p><p>В этом разделе рассматриваются детали реализации и другие приемы, которые полезно знать разработчикам классов операторов SP-GiST.</p><p>Отдельные кортежи листьев и внутренние кортежи должны помещаться на одной странице индекса (по умолчанию 8 КБ). Поэтому при индексировании значений типов данных переменной длины длинные значения могут поддерживаться только такими методами, как radix trees, в которых каждый уровень дерева включает префикс, который достаточно короток для размещения на странице, а последний уровень листьев включает суффикс, также достаточно короток для размещения на странице. Класс оператора должен устанавливать longValuesOK в значение true, только если он готов это организовать. В противном случае ядро ​​SP-GiST отклонит любой запрос на индексирование значения, которое слишком велико для размещения на странице индекса.</p><p>Аналогично, класс операторов отвечает за то, чтобы внутренние кортежи не становились слишком большими, чтобы поместиться на странице индекса; это ограничивает количество дочерних узлов, которые могут использоваться в одном внутреннем кортеже, а также максимальный размер значения префикса.</p><p>Другое ограничение заключается в том, что когда узел внутреннего кортежа указывает на набор конечных кортежей, все эти кортежи должны находиться на одной странице индекса. (Это проектное решение для сокращения поиска и экономии места в ссылках, которые связывают такие кортежи вместе.) Если набор конечных кортежей становится слишком большим для страницы, выполняется разделение и вставляется промежуточный внутренний кортеж. Чтобы это исправило проблему, новый внутренний кортеж должен разделить набор конечных значений на более чем одну группу узлов. Если функция picksplit класса оператора не может этого сделать, ядро ​​SP-GiST прибегает к чрезвычайным мерам, описанным в разделе 64.3.4.3.</p><p>Когда longValuesOK имеет значение true, ожидается, что последующие уровни дерева SP-GiST будут поглощать все больше и больше информации в префиксы и метки узлов внутренних кортежей, делая требуемый листовой элемент данных все меньше и меньше, так что в конечном итоге он поместится на странице. Чтобы предотвратить возникновение бесконечных циклов вставки из-за ошибок в классах операторов, ядро ​​SP-GiST выдаст ошибку, если листовой элемент данных не станет меньше в течение десяти циклов вызовов метода select.</p><p>Некоторые алгоритмы деревьев используют фиксированный набор узлов для каждого внутреннего кортежа; например, в квадродереве всегда ровно четыре узла, соответствующих четырем квадрантам вокруг точки центроида внутреннего кортежа. В таком случае код обычно работает с узлами по номеру, и нет необходимости в явных метках узлов. Чтобы подавить метки узлов (и тем самым сэкономить немного места), функция picksplit может возвращать NULL для массива nodeLabels, и аналогично функция choose может возвращать NULL для массива prefixNodeLabels во время действия spgSplitTuple. Это, в свою очередь, приведет к тому, что nodeLabels будет NULL во время последующих вызовов choose и inner_consistent. В принципе, метки узлов могут использоваться для некоторых внутренних кортежей и опускаться для других в том же индексе.</p><p>При работе с внутренним кортежем, имеющим непомеченные узлы, выбор возврата spgAddNode является ошибкой, поскольку в таких случаях предполагается, что набор узлов фиксирован.</p><p>Ядро SP-GiST может переопределить результаты функции picksplit класса оператора, когда picksplit не может разделить предоставленные значения листьев по крайней мере на две категории узлов. Когда это происходит, создается новый внутренний кортеж с несколькими узлами, каждый из которых имеет ту же метку (если таковая имеется), которую picksplit дал одному узлу, который он использовал, и значения листьев случайным образом распределяются между этими эквивалентными узлами. Флаг allTheSame устанавливается на внутреннем кортеже, чтобы предупредить функции select и inner_consistent о том, что кортеж не имеет набора узлов, который они могли бы ожидать в противном случае.</p><p>При работе с кортежем allTheSame результат выбора spgMatchNode интерпретируется как означающий, что новое значение может быть назначено любому из эквивалентных узлов; основной код проигнорирует предоставленное значение nodeN и спустится в один из узлов случайным образом (чтобы сохранить сбалансированность дерева). Возвращение spgAddNode является ошибкой выбора, поскольку это сделало бы не все узлы эквивалентными; действие spgSplitTuple должно использоваться, если вставляемое значение не соответствует существующим узлам.</p><p>При работе с кортежем allTheSame функция inner_consistent должна возвращать либо все, либо ни одного узла в качестве целей для продолжения поиска индекса, поскольку все они эквивалентны. Это может потребовать или не потребовать специального кода, в зависимости от того, насколько функция inner_consistent обычно предполагает значение узлов.</p><p>Исходный дистрибутив PostgreSQL включает несколько примеров классов операторов индекса для SP-GiST, как описано в Таблице 64.2. Посмотрите в src/backend/access/spgist/ и src/backend/utils/adt/, чтобы увидеть код.</p>

<h2>64.4. GIN Indexes #</h2>
<p>GIN означает Generalized Inverted Index (Обобщенный инвертированный индекс). GIN предназначен для обработки случаев, когда индексируемые элементы являются составными значениями, а запросы, которые должны обрабатываться индексом, должны искать значения элементов, которые появляются в составных элементах. Например, элементы могут быть документами, а запросы могут быть поисками документов, содержащих определенные слова.</p><p>Мы используем слово item для обозначения составного значения, которое должно быть проиндексировано, а слово key для обозначения значения элемента. GIN всегда хранит и ищет ключи, а не значения элементов как таковые.</p><p>Индекс GIN хранит набор пар (ключ, список размещения), где список размещения — это набор идентификаторов строк, в которых встречается ключ. Один и тот же идентификатор строки может встречаться в нескольких списках размещения, поскольку элемент может содержать более одного ключа. Каждое значение ключа хранится только один раз, поэтому индекс GIN очень компактен для случаев, когда один и тот же ключ встречается много раз.</p><p>GIN обобщен в том смысле, что код метода доступа GIN не должен знать конкретные операции, которые он ускоряет. Вместо этого он использует пользовательские стратегии, определенные для определенных типов данных. Стратегия определяет, как ключи извлекаются из индексированных элементов и условий запроса, и как определить, удовлетворяет ли строка, содержащая некоторые из ключевых значений в запросе, на самом деле запросу.</p><p>Одним из преимуществ GIN является то, что он позволяет разрабатывать пользовательские типы данных с соответствующими методами доступа эксперту в области типа данных, а не эксперту по базам данных. Это во многом то же самое преимущество, что и использование GiST.</p><p>Реализацию GIN в PostgreSQL в основном поддерживают Теодор Сигаев и Олег Бартунов. Более подробная информация о GIN доступна на их сайте.</p><p>Основной дистрибутив PostgreSQL включает классы операторов GIN, показанные в таблице 64.3. (Некоторые из дополнительных модулей, описанных в приложении F, предоставляют дополнительные классы операторов GIN.)</p><p>Таблица 64.3. Встроенные классы операторов GIN</p><p>Из двух классов операторов для типа jsonb, jsonb_ops является классом по умолчанию. jsonb_path_ops поддерживает меньше операторов, но обеспечивает лучшую производительность для этих операторов. Подробности см. в разделе 8.14.4.</p><p>Интерфейс GIN имеет высокий уровень абстракции, требуя от реализатора метода доступа только реализации семантики типа данных, к которому осуществляется доступ. Сам уровень GIN заботится о параллелизме, ведении журнала и поиске в древовидной структуре.</p><p>Все, что нужно для того, чтобы метод доступа GIN заработал, — это реализовать несколько пользовательских методов, которые определяют поведение ключей в дереве и отношения между ключами, индексированными элементами и индексируемыми запросами. Короче говоря, GIN сочетает расширяемость с универсальностью, повторное использование кода и чистый интерфейс.</p><p>Класс оператора для GIN должен предоставлять два метода:</p><p>Возвращает palloc'd массив ключей, заданных элементом для индексации. Количество возвращенных ключей должно быть сохранено в *nkeys. Если какой-либо из ключей может быть null, также palloc массив из *nkeys bool полей, сохраните его адрес в *nullFlags и установите эти null флаги по мере необходимости. *nullFlags можно оставить NULL (его начальное значение), если все ключи не равны null. Возвращаемое значение может быть NULL, если элемент не содержит ключей.</p><p>Возвращает palloc'd массив ключей, заданных значением для запроса; то есть query — это значение в правой части индексируемого оператора, левая часть которого — индексированный столбец. n — это номер стратегии оператора в классе операторов (см. раздел 36.16.2). Часто extractQuery необходимо будет обратиться к n, чтобы определить тип данных запроса и метод, который он должен использовать для извлечения значений ключей. Количество возвращаемых ключей должно быть сохранено в *nkeys. Если какой-либо из ключей может быть пустым, также palloc массив из *nkeys полей bool, сохраните его адрес в *nullFlags и установите эти флаги null по мере необходимости. *nullFlags можно оставить равным NULL (его начальное значение), если все ключи не равны NULL. Возвращаемое значение может быть равно NULL, если запрос не содержит ключей.</p><p>searchMode — это выходной аргумент, позволяющий extractQuery указывать сведения о том, как будет выполняться поиск. Если *searchMode установлен в GIN_SEARCH_MODE_DEFAULT (это значение, которому он инициализируется перед вызовом), то только элементы, соответствующие хотя бы одному из возвращенных ключей, считаются кандидатами на совпадения. Если *searchMode установлен в GIN_SEARCH_MODE_INCLUDE_EMPTY, то в дополнение к элементам, содержащим хотя бы один совпадающий ключ, элементы, не содержащие ключей вообще, считаются кандидатами на совпадения. (Этот режим полезен, например, для реализации операторов is-subset-of.) Если *searchMode установлен в GIN_SEARCH_MODE_ALL, то все ненулевые элементы в индексе считаются кандидатами на совпадения, независимо от того, соответствуют ли они какому-либо из возвращенных ключей или нет. (Этот режим намного медленнее двух других вариантов, поскольку он требует сканирования по сути всего индекса, но может потребоваться правильная реализация крайних случаев. Оператор, которому в большинстве случаев требуется этот режим, вероятно, не является хорошим кандидатом для класса операторов GIN.) Символы, используемые для установки этого режима, определены в access/gin.h.</p><p>pmatch — это выходной аргумент для использования, когда поддерживается частичное совпадение. Чтобы использовать его, extractQuery должен выделить массив *nkeys bool и сохранить его адрес в *pmatch. Каждый элемент массива должен быть установлен в true, если соответствующий ключ требует частичного совпадения, и в false, если нет. Если *pmatch установлен в NULL, то GIN предполагает, что частичное совпадение не требуется. Переменная инициализируется значением NULL перед вызовом, поэтому этот аргумент может просто игнорироваться классами операторов, которые не поддерживают частичное совпадение.</p><p>extra_data — это выходной аргумент, который позволяет extractQuery передавать дополнительные данные в методы conform и comparePartial. Чтобы использовать его, extractQuery должен выделить массив указателей *nkeys и сохранить его адрес в *extra_data, а затем сохранить все, что он хочет, в отдельных указателях. Переменная инициализируется значением NULL перед вызовом, поэтому этот аргумент может просто игнорироваться классами операторов, которым не требуются дополнительные данные. Если задано *extra_data, весь массив передается в метод conform, а соответствующий элемент — в метод comparePartial.</p><p>Класс оператора также должен предоставлять функцию для проверки соответствия индексированного элемента запросу. Он поставляется в двух вариантах: булева согласованная функция и тернарная функция triConsistent. triConsistent охватывает функциональность обеих, поэтому предоставления только triConsistent достаточно. Однако, если булев вариант значительно дешевле для вычисления, может быть выгодно предоставить оба. Если предоставляется только булев вариант, некоторые оптимизации, которые зависят от опровержения элементов индекса перед извлечением всех ключей, отключаются.</p><p>Возвращает true, если индексированный элемент удовлетворяет оператору запроса со стратегией номер n (или может удовлетворять ему, если возвращается указание повторной проверки). Эта функция не имеет прямого доступа к значению индексированного элемента, поскольку GIN не хранит элементы явно. Вместо этого доступны знания о том, какие значения ключей, извлеченные из запроса, появляются в данном индексированном элементе. Массив проверки имеет длину nkeys, что совпадает с количеством ключей, ранее возвращенных extractQuery для этого элемента данных запроса. Каждый элемент массива проверки имеет значение true, если индексированный элемент содержит соответствующий ключ запроса, т. е. если (check[i] == true) i-й ключ массива результатов extractQuery присутствует в индексированном элементе. Исходный элемент данных запроса передается в случае, если методу conformance необходимо обратиться к нему, как и массивы queryKeys[] и nullFlags[], ранее возвращенные extractQuery. extra_data — это массив дополнительных данных, возвращаемый extractQuery, или NULL, если нет.</p><p>Когда extractQuery возвращает нулевой ключ в queryKeys[], соответствующий элемент check[] имеет значение true, если индексированный элемент содержит нулевой ключ; то есть семантика check[] похожа на IS NOT DISTINCT FROM. Консистентная функция может проверить соответствующий элемент nullFlags[], если ей нужно определить разницу между обычным соответствием значения и нулевым соответствием.</p><p>При успешном выполнении *recheck следует установить в значение true, если кортеж кучи необходимо перепроверить с помощью оператора запроса, или в значение false, если проверка индекса точна. То есть возвращаемое значение false гарантирует, что кортеж кучи не соответствует запросу; возвращаемое значение true с *recheck, установленным в значение false, гарантирует, что кортеж кучи соответствует запросу; а возвращаемое значение true с *recheck, установленным в значение true, означает, что кортеж кучи может соответствовать запросу, поэтому его необходимо извлечь и перепроверить, оценив оператор запроса напрямую по изначально индексированному элементу.</p><p>triConsistent похож на conform, но вместо булевых значений в проверочном векторе есть три возможных значения для каждого ключа: GIN_TRUE, GIN_FALSE и GIN_MAYBE. GIN_FALSE и GIN_TRUE имеют то же значение, что и обычные булевые значения, в то время как GIN_MAYBE означает, что наличие этого ключа неизвестно. Когда присутствуют значения GIN_MAYBE, функция должна возвращать GIN_TRUE только в том случае, если элемент определенно совпадает, независимо от того, содержит ли элемент индекса соответствующие ключи запроса. Аналогично, функция должна возвращать GIN_FALSE только в том случае, если элемент определенно не совпадает, независимо от того, содержит ли он ключи GIN_MAYBE. Если результат зависит от записей GIN_MAYBE, т. е. совпадение не может быть подтверждено или опровергнуто на основе известных ключей запроса, функция должна возвращать GIN_MAYBE.</p><p>Если в проверочном векторе нет значений GIN_MAYBE, возвращаемое значение GIN_MAYBE эквивалентно установке флага повторной проверки в логической согласованной функции.</p><p>Кроме того, GIN должен иметь способ сортировки ключевых значений, хранящихся в индексе. Класс оператора может определить порядок сортировки, указав метод сравнения:</p><p>Сравнивает два ключа (не индексированные элементы!) и возвращает целое число меньше нуля, ноль или больше нуля, указывая, является ли первый ключ меньше, равен или больше второго. Пустые ключи никогда не передаются в эту функцию.</p><p>В качестве альтернативы, если класс операторов не предоставляет метод сравнения, GIN будет искать класс операторов btree по умолчанию для типа данных ключа индекса и использовать его функцию сравнения. Рекомендуется указывать функцию сравнения в классе операторов GIN, который предназначен только для одного типа данных, так как поиск класса операторов btree занимает несколько циклов. Однако полиморфные классы операторов GIN (такие как array_ops) обычно не могут указывать одну функцию сравнения.</p><p>Класс оператора для GIN может опционально предоставлять следующие методы:</p><p>Сравнение ключа запроса с частичным совпадением с ключом индекса. Возвращает целое число, знак которого указывает на результат: меньше нуля означает, что ключ индекса не соответствует запросу, но сканирование индекса должно продолжаться; ноль означает, что ключ индекса соответствует запросу; больше нуля означает, что сканирование индекса должно быть остановлено, поскольку больше совпадений невозможны. Предоставляется номер стратегии n оператора, сгенерировавшего запрос с частичным совпадением, на случай, если его семантика необходима для определения того, когда следует завершить сканирование. Кроме того, extra_data является соответствующим элементом массива дополнительных данных, созданного extractQuery, или NULL, если его нет. Пустые ключи никогда не передаются в эту функцию.</p><p>Определяет набор видимых пользователю параметров, которые управляют поведением класса оператора.</p><p>Функция options передает указатель на структуру local_relopts, которую необходимо заполнить набором опций, специфичных для класса операторов. Доступ к опциям можно получить из других функций поддержки с помощью макросов PG_HAS_OPCLASS_OPTIONS() и PG_GET_OPCLASS_OPTIONS().</p><p>Поскольку как извлечение ключа из индексированных значений, так и представление ключа в GIN являются гибкими, они могут зависеть от указанных пользователем параметров.</p><p>Для поддержки запросов «частичного соответствия» класс оператора должен предоставлять метод comparePartial, а его метод extractQuery должен устанавливать параметр pmatch при обнаружении запроса частичного соответствия. Подробности см. в разделе 64.4.4.2.</p><p>Фактические типы данных различных значений Datum, упомянутых выше, различаются в зависимости от класса оператора. Значения элементов, передаваемые в extractValue, всегда имеют тип ввода класса оператора, а все ключевые значения должны иметь тип STORAGE класса. Тип аргумента запроса, передаваемого в extractQuery, consist и triConsistent, — это тот, который является правым типом ввода оператора-члена класса, идентифицированного номером стратегии. Он не обязательно должен совпадать с индексированным типом, если из него можно извлечь ключевые значения правильного типа. Однако рекомендуется, чтобы объявления SQL этих трех функций поддержки использовали индексированный тип данных opclass для аргумента запроса, даже если фактический тип может быть другим в зависимости от оператора.</p><p>Внутри индекс GIN содержит индекс B-дерева, построенный по ключам, где каждый ключ является элементом одного или нескольких индексированных элементов (например, членом массива) и где каждый кортеж на странице листа содержит либо указатель на B-дерево указателей кучи («дерево размещения»), либо простой список указателей кучи («список размещения»), когда список достаточно мал, чтобы поместиться в один индексный кортеж вместе со значением ключа. Рисунок 64.1 иллюстрирует эти компоненты индекса GIN.</p><p>Начиная с PostgreSQL 9.1, в индекс могут быть включены нулевые значения ключей. Кроме того, пустые значения-заполнители включаются в индекс для индексированных элементов, которые являются нулевыми или не содержат ключей согласно extractValue. Это позволяет выполнять поиск, который должен находить пустые элементы.</p><p>Многостолбцовые индексы GIN реализуются путем построения одного B-дерева по составным значениям (номер столбца, ключевое значение). Ключевое значение для разных столбцов может быть разного типа.</p><p>Рисунок 64.1. Внутреннее устройство GIN</p><p>Обновление индекса GIN, как правило, происходит медленно из-за внутренней природы инвертированных индексов: вставка или обновление одной строки кучи может вызвать множество вставок в индекс (по одной для каждого ключа, извлеченного из индексированного элемента). GIN способен отложить большую часть этой работы, вставляя новые кортежи во временный, несортированный список ожидающих записей. Когда таблица очищается или автоматически анализируется, или когда вызывается функция gin_clean_pending_list, или если ожидающий список становится больше gin_pending_list_limit, записи перемещаются в основную структуру данных GIN с использованием тех же методов массовой вставки, которые использовались при первоначальном создании индекса. Это значительно повышает скорость обновления индекса GIN, даже учитывая дополнительные накладные расходы на очистку. Более того, накладные расходы могут быть выполнены фоновым процессом вместо обработки запроса на переднем плане.</p><p>Главным недостатком этого подхода является то, что поиск должен сканировать список ожидающих записей в дополнение к поиску в обычном индексе, и поэтому большой список ожидающих записей значительно замедлит поиск. Другим недостатком является то, что, хотя большинство обновлений быстрые, обновление, которое приводит к тому, что ожидающий список становится «слишком большим», повлечет за собой немедленный цикл очистки и, таким образом, будет намного медленнее, чем другие обновления. Правильное использование автоочистки может минимизировать обе эти проблемы.</p><p>Если согласованное время отклика важнее скорости обновления, использование ожидающих записей можно отключить, отключив параметр хранения fastupdate для индекса GIN. Подробности см. в разделе CREATE INDEX.</p><p>GIN может поддерживать запросы «частичного соответствия», в которых запрос не определяет точное совпадение для одного или нескольких ключей, но возможные совпадения попадают в разумно узкий диапазон значений ключей (в пределах порядка сортировки ключей, определенного методом поддержки сравнения). Метод extractQuery, вместо возврата значения ключа для точного сопоставления, возвращает значение ключа, которое является нижней границей диапазона для поиска, и устанавливает флаг pmatch в значение true. Затем диапазон ключей сканируется с помощью метода comparePartial. comparePartial должен возвращать ноль для совпадающего индексного ключа, меньше нуля для несовпадения, которое все еще находится в диапазоне для поиска, или больше нуля, если индексный ключ выходит за пределы диапазона, который может совпасть.</p><p>Вставка в индекс GIN может быть медленной из-за вероятности вставки многих ключей для каждого элемента. Поэтому для массовых вставок в таблицу рекомендуется удалить индекс GIN и создать его заново после завершения массовой вставки.</p><p>Когда fastupdate включен для GIN (см. раздел 64.4.4.1 для получения подробной информации), штраф меньше, чем когда он не включен. Но для очень больших обновлений все равно может быть лучше удалить и пересоздать индекс.</p><p>Время построения индекса GIN очень чувствительно к настройке maintenance_work_mem; не стоит экономить на рабочей памяти при создании индекса.</p><p>Во время серии вставок в существующий индекс GIN, в котором включен fastupdate, система будет очищать список ожидающих записей всякий раз, когда список становится больше gin_pending_list_limit. Чтобы избежать колебаний в наблюдаемом времени отклика, желательно, чтобы очистка ожидающих записей происходила в фоновом режиме (т. е. с помощью автоочистки). Операции очистки переднего плана можно избежать, увеличив gin_pending_list_limit или сделав автоочистку более агрессивной. Однако увеличение порога операции очистки означает, что если очистка переднего плана действительно произойдет, она займет еще больше времени.</p><p>gin_pending_list_limit можно переопределить для отдельных индексов GIN, изменив параметры хранения, что позволяет каждому индексу GIN иметь свой собственный порог очистки. Например, можно увеличить порог только для индекса GIN, который может обновляться интенсивно, и уменьшить его в противном случае.</p><p>Основной целью разработки индексов GIN было создание поддержки высокомасштабируемого полнотекстового поиска в PostgreSQL, и часто возникают ситуации, когда полнотекстовый поиск возвращает очень большой набор результатов. Более того, это часто происходит, когда запрос содержит очень частые слова, так что большой набор результатов даже бесполезен. Поскольку чтение множества кортежей с диска и их сортировка могут занять много времени, это неприемлемо для производства. (Обратите внимание, что сам поиск по индексу очень быстрый.)</p><p>Для облегчения контролируемого выполнения таких запросов GIN имеет настраиваемый мягкий верхний предел количества возвращаемых строк: параметр конфигурации gin_fuzzy_search_limit. По умолчанию он установлен на 0 (что означает отсутствие предела). Если установлен ненулевой предел, то возвращаемый набор является подмножеством всего набора результатов, выбранным случайным образом.</p><p>«Мягкий» означает, что фактическое количество возвращаемых результатов может несколько отличаться от указанного предела в зависимости от запроса и качества генератора случайных чисел системы.</p><p>По опыту, значения в тысячи (например, 5000–20000) работают хорошо.</p><p>GIN предполагает, что индексируемые операторы являются строгими. Это означает, что extractValue вообще не будет вызываться для нулевого значения элемента (вместо этого автоматически создается запись индекса-заполнителя), а extractQuery также не будет вызываться для нулевого значения запроса (вместо этого запрос предполагается невыполнимым). Однако следует отметить, что поддерживаются нулевые значения ключа, содержащиеся в ненулевом составном элементе или значении запроса.</p><p>Основной дистрибутив PostgreSQL включает классы операторов GIN, ранее показанные в Таблице 64.3. Следующие модули contrib также содержат классы операторов GIN:</p><p>Эквивалентная функциональность B-дерева для нескольких типов данных</p><p>Модуль для хранения пар (ключ, значение)</p><p>Расширенная поддержка int[]</p><p>Сходство текста с использованием сопоставления триграмм</p>

<h2>64.5. BRIN Indexes #</h2>
<p>BRIN означает Block Range Index (индекс диапазона блоков). BRIN предназначен для обработки очень больших таблиц, в которых определенные столбцы имеют некоторую естественную корреляцию с их физическим расположением внутри таблицы.</p><p>BRIN работает с точки зрения диапазонов блоков (или «диапазонов страниц»). Диапазон блоков — это группа страниц, которые физически соседствуют в таблице; для каждого диапазона блоков индексом хранится некоторая сводная информация. Например, таблица, в которой хранятся заказы магазина на продажу, может иметь столбец даты, в который был размещен каждый заказ, и в большинстве случаев записи для более ранних заказов также будут отображаться раньше в таблице; таблица, в которой хранится столбец почтового индекса, может иметь все коды для города, сгруппированные вместе естественным образом.</p><p>Индексы BRIN могут удовлетворять запросы посредством обычного сканирования индекса bitmap и возвращают все кортежи на всех страницах в каждом диапазоне, если сводная информация, хранящаяся в индексе, соответствует условиям запроса. Исполнитель запроса отвечает за повторную проверку этих кортежей и отбрасывание тех, которые не соответствуют условиям запроса — другими словами, эти индексы являются индексами с потерями. Поскольку индекс BRIN очень мал, сканирование индекса добавляет небольшие накладные расходы по сравнению с последовательным сканированием, но может избежать сканирования больших частей таблицы, которые, как известно, не содержат соответствующих кортежей.</p><p>Конкретные данные, которые будет хранить индекс BRIN, а также конкретные запросы, которые индекс сможет удовлетворить, зависят от класса операторов, выбранного для каждого столбца индекса. Типы данных, имеющие линейный порядок сортировки, могут иметь классы операторов, которые хранят минимальное и максимальное значение в пределах каждого диапазона блока, например; геометрические типы могут хранить ограничивающий прямоугольник для всех объектов в диапазоне блока.</p><p>Размер диапазона блоков определяется во время создания индекса параметром хранения pages_per_range. Количество записей индекса будет равно размеру отношения в страницах, деленному на выбранное значение pages_per_range. Таким образом, чем меньше число, тем больше становится индекс (из-за необходимости хранить больше записей индекса), но в то же время хранимые сводные данные могут быть более точными, и больше блоков данных можно пропустить во время сканирования индекса.</p><p>Во время создания все существующие страницы кучи сканируются, и для каждого диапазона создается сводная индексная запись, включая возможно неполный диапазон в конце. По мере заполнения новых страниц данными диапазоны страниц, которые уже суммированы, приведут к обновлению сводной информации данными из новых кортежей. Когда создается новая страница, которая не попадает в последний суммированный диапазон, диапазон, к которому принадлежит новая страница, автоматически не получает сводную запись; эти кортежи остаются несуммированными до тех пор, пока позже не будет вызван запуск суммирования, создающий начальную сводку для этого диапазона.</p><p>Существует несколько способов запустить начальное суммирование диапазона страниц. Если таблица очищается вручную или с помощью автоочистки, все существующие несуммированные диапазоны страниц суммируются. Кроме того, если параметр автосуммирования индекса включен, что не является таковым по умолчанию, всякий раз, когда автоочистка запускается в этой базе данных, суммирование будет выполняться для всех несуммированных диапазонов страниц, которые были заполнены, независимо от того, обрабатывается ли сама таблица с помощью автоочистки; см. ниже.</p><p>Наконец, можно использовать следующие функции (во время работы этих функций search_path временно изменяется на pg_catalog, pg_temp):</p><p>Когда включена автосуммирование, запрос отправляется в автовакуум для выполнения целевого суммирования для диапазона блоков, когда обнаруживается вставка для первого элемента первой страницы следующего диапазона блоков, которая будет выполнена в следующий раз, когда работник автовакуума закончит работу в той же базе данных. Если очередь запросов заполнена, запрос не регистрируется, а в журнал сервера отправляется сообщение:</p><p>В этом случае диапазон останется необработанным до следующего регулярного запуска вакуумной очистки таблицы или до вызова одной из функций, упомянутых выше.</p><p>И наоборот, диапазон может быть десуммирован с помощью функции brin_desummarize_range(regclass, bigint), которая полезна, когда индексный кортеж больше не является хорошим представлением, поскольку существующие значения изменились. Подробности см. в разделе 9.28.8.</p><p>Основной дистрибутив PostgreSQL включает классы операторов BRIN, показанные в таблице 64.4.</p><p>Классы операторов minmax хранят минимальные и максимальные значения, появляющиеся в индексированном столбце в пределах диапазона. Классы операторов include хранят значение, которое включает значения в индексированном столбце в пределах диапазона. Классы операторов bloom создают фильтр Bloom для всех значений в диапазоне. Классы операторов minmax-multi хранят несколько минимальных и максимальных значений, представляющих значения, появляющиеся в индексированном столбце в пределах диапазона.</p><p>Таблица 64.4. Встроенные классы операторов BRIN</p><p>Некоторые из встроенных классов операторов позволяют указывать параметры, влияющие на поведение класса операторов. Каждый класс операторов имеет свой собственный набор разрешенных параметров. Только классы операторов bloom и minmax-multi позволяют указывать параметры:</p><p>Классы операторов Блума принимают следующие параметры:</p><p>Определяет предполагаемое количество отдельных ненулевых значений в диапазоне блоков, используемых индексами Блума BRIN для определения размера фильтра Блума. Он ведет себя аналогично параметру n_distinct для ALTER TABLE. При установке положительного значения предполагается, что каждый диапазон блоков содержит это количество отдельных ненулевых значений. При установке отрицательного значения, которое должно быть больше или равно -1, предполагается, что количество отдельных ненулевых значений растет линейно с максимально возможным количеством кортежей в диапазоне блоков (около 290 строк на блок). Значение по умолчанию равно -0,1, а минимальное количество отдельных ненулевых значений равно 16.</p><p>Определяет желаемый уровень ложных срабатываний, используемый индексами Блума BRIN для определения размера фильтра Блума. Значения должны быть в диапазоне от 0,0001 до 0,25. Значение по умолчанию — 0,01, что составляет 1% уровня ложных срабатываний.</p><p>Классы операторов minmax-multi принимают следующие параметры:</p><p>Определяет максимальное количество значений, хранящихся в индексах BRIN minmax для суммирования диапазона блоков. Каждое значение может представлять либо точку, либо границу интервала. Значения должны быть в диапазоне от 8 до 256, а значение по умолчанию — 32.</p><p>Интерфейс BRIN имеет высокий уровень абстракции, требуя от реализатора метода доступа только реализации семантики типа данных, к которому осуществляется доступ. Сам слой BRIN заботится о параллелизме, ведении журнала и поиске в структуре индекса.</p><p>Все, что нужно для того, чтобы метод доступа BRIN заработал, — это реализовать несколько пользовательских методов, которые определяют поведение сводных значений, хранящихся в индексе, и то, как они взаимодействуют с ключами сканирования. Короче говоря, BRIN сочетает расширяемость с универсальностью, повторное использование кода и чистый интерфейс.</p><p>Класс оператора для BRIN должен предоставлять четыре метода:</p><p>Возвращает внутреннюю информацию о сводных данных индексированных столбцов. Возвращаемое значение должно указывать на palloc'd BrinOpcInfo, который имеет следующее определение:</p><p>Brinopcinfo.oi_opaque может использоваться подпрограммами класса оператора для передачи информации между функциями поддержки во время индексного сканирования.</p><p>Возвращает, соответствуют ли все записи ScanKey заданным индексированным значениям для диапазона. Номер атрибута для использования передается как часть ключа сканирования. Несколько ключей сканирования для одного и того же атрибута могут быть переданы одновременно; количество записей определяется параметром nkeys.</p><p>Возвращает, соответствует ли сканирование с данными индексированными значениями для диапазона.</p><p>При наличии индексного кортежа и индексированного значения изменяет указанный атрибут кортежа так, чтобы он дополнительно представлял новое значение. Если в кортеж были внесены какие-либо изменения, возвращается значение true.</p><p>Объединяет два кортежа индексов. При наличии двух кортежей индексов изменяет указанный атрибут первого из них так, чтобы он представлял оба кортежа. Второй кортеж не изменяется.</p><p>Класс оператора для BRIN может опционально указывать следующий метод:</p><p>Определяет набор видимых пользователю параметров, которые управляют поведением класса оператора.</p><p>Функция «Параметры» передается по указанию на структуру локального_релопта, которая должна быть заполнена набором специфических параметров класса оператора.</p><p>Поскольку как извлечение ключа из индексированных значений, так и представление ключа в BRIN являются гибкими, они могут зависеть от указанных пользователем параметров.</p><p>Основной дистрибутив включает поддержку четырех типов классов операторов: minmax, minmax-multi, include и bloom. Определения классов операторов, использующие их, поставляются для типов данных ядра по мере необходимости. Дополнительные классы операторов могут быть определены пользователем для других типов данных с использованием эквивалентных определений без необходимости писать какой-либо исходный код; достаточно объявить соответствующие записи каталога. Обратите внимание, что предположения о семантике стратегий операторов встроены в исходный код функций поддержки.</p><p>Классы операторов, реализующие совершенно другую семантику, также возможны, при условии, что написаны реализации четырех основных функций поддержки, описанных выше. Обратите внимание, что обратная совместимость между основными выпусками не гарантируется: например, в более поздних выпусках могут потребоваться дополнительные функции поддержки.</p><p>Чтобы написать класс операторов для типа данных, который реализует полностью упорядоченный набор, можно использовать функции поддержки minmax вместе с соответствующими операторами, как показано в таблице 64.5. Все члены класса операторов (функции и операторы) являются обязательными.</p><p>Таблица 64.5. Функции и опорные числа для классов операторов Minmax</p><p>Чтобы написать класс операторов для сложного типа данных, значения которого включены в другой тип, можно использовать функции поддержки включения вместе с соответствующими операторами, как показано в таблице 64.6. Для этого требуется только одна дополнительная функция, которая может быть написана на любом языке. Для дополнительной функциональности можно определить больше функций. Все операторы являются необязательными. Для некоторых операторов требуются другие операторы, как показано в виде зависимостей в таблице.</p><p>Таблица 64.6. Функции и опорные числа для классов операторов включения</p><p>Номера функций поддержки от 1 до 10 зарезервированы для внутренних функций BRIN, поэтому функции уровня SQL начинаются с номера 11. Функция поддержки номер 11 является основной функцией, необходимой для построения индекса. Она должна принимать два аргумента с тем же типом данных, что и класс оператора, и возвращать их объединение. Класс оператора включения может хранить значения объединения с разными типами данных, если он определен с параметром STORAGE. Возвращаемое значение функции объединения должно соответствовать типу данных STORAGE.</p><p>Функции поддержки 12 и 14 предусмотрены для поддержки нерегулярностей встроенных типов данных. Функция 12 используется для поддержки сетевых адресов из разных семейств, которые не могут быть объединены. Функция 14 используется для поддержки пустых диапазонов. Функция 13 является необязательной, но рекомендуемой, она позволяет проверять новое значение перед его передачей в функцию объединения. Поскольку фреймворк BRIN может сокращать некоторые операции, когда объединение не изменяется, использование этой функции может улучшить производительность индекса.</p><p>Чтобы написать класс операторов для типа данных, который реализует только оператор равенства и поддерживает хеширование, можно использовать процедуры поддержки Блума вместе с соответствующими операторами, как показано в Таблице 64.7. Все члены класса операторов (процедуры и операторы) являются обязательными.</p><p>Таблица 64.7. Процедуры и опорные числа для классов операторов Блума</p><p>Номера вспомогательных процедур 1-10 зарезервированы для внутренних функций BRIN, поэтому функции уровня SQL начинаются с номера 11. Вспомогательная функция номер 11 — это основная функция, необходимая для построения индекса. Она должна принимать один аргумент с тем же типом данных, что и класс оператора, и возвращать хэш значения.</p><p>Класс операторов minmax-multi также предназначен для типов данных, реализующих полностью упорядоченный набор, и может рассматриваться как простое расширение класса операторов minmax. В то время как класс операторов minmax суммирует значения из каждого диапазона блоков в один непрерывный интервал, minmax-multi допускает суммирование в несколько меньших интервалов для улучшения обработки выбросов. Можно использовать процедуры поддержки minmax-multi вместе с соответствующими операторами, как показано в таблице 64.8. Все члены класса операторов (процедуры и операторы) являются обязательными.</p><p>Таблица 64.8. Процедуры и опорные числа для классов операторов minmax-multi</p><p>Оба класса операторов minmax и include поддерживают операторы перекрестных типов данных, хотя с ними зависимости становятся более сложными. Класс операторов minmax требует определения полного набора операторов с обоими аргументами, имеющими одинаковый тип данных. Он позволяет поддерживать дополнительные типы данных, определяя дополнительные наборы операторов. Стратегии операторов класса операторов включения зависят от другой стратегии оператора, как показано в таблице 64.6, или той же стратегии оператора, что и они сами. Они требуют, чтобы оператор зависимости был определен с типом данных STORAGE в качестве левого аргумента, а другой поддерживаемый тип данных был правым аргументом поддерживаемого оператора. См. float4_minmax_ops в качестве примера minmax и box_inclusion_ops в качестве примера включения.</p>

<h2>64.6. Hash Indexes #</h2>
<p>PostgreSQL включает реализацию постоянных хэш-индексов на диске, которые полностью восстанавливаются после сбоя. Любой тип данных может быть проиндексирован хэш-индексом, включая типы данных, которые не имеют четко определенного линейного порядка. Хэш-индексы хранят только хэш-значение индексируемых данных, поэтому нет ограничений на размер индексируемого столбца данных.</p><p>Хэш-индексы поддерживают только одностолбцовые индексы и не позволяют проверять уникальность.</p><p>Хэш-индексы поддерживают только оператор =, поэтому предложения WHERE, определяющие операции с диапазонами, не смогут воспользоваться преимуществами хэш-индексов.</p><p>Каждый кортеж индекса хэша хранит только 4-байтовое значение хэша, а не фактическое значение столбца. В результате индексы хэша могут быть намного меньше B-деревьев при индексировании более длинных элементов данных, таких как UUID, URL и т. д. Отсутствие значения столбца также делает все сканирования индекса хэша потерями. Индексы хэша могут принимать участие в сканированиях индекса битовой карты и обратном сканировании.</p><p>Хэш-индексы лучше всего оптимизированы для рабочих нагрузок с большими объемами SELECT и UPDATE, которые используют сканирование равенства в больших таблицах. В индексе B-дерева поиск должен спускаться по дереву, пока не будет найдена конечная страница. В таблицах с миллионами строк этот спуск может увеличить время доступа к данным. Эквивалент конечной страницы в хэш-индексе называется страницей контейнера. Напротив, хэш-индекс позволяет получать доступ к страницам контейнера напрямую, тем самым потенциально сокращая время доступа к индексу в больших таблицах. Это сокращение «логического ввода-вывода» становится еще более выраженным для индексов/данных, больших, чем shared_buffers/RAM.</p><p>Индексы хэша были разработаны для того, чтобы справляться с неравномерным распределением значений хэша. Прямой доступ к страницам контейнера работает хорошо, если значения хэша распределены равномерно. Когда вставки приводят к заполнению страницы контейнера, дополнительные страницы переполнения привязываются к этой конкретной странице контейнера, локально расширяя хранилище для кортежей индекса, которые соответствуют этому значению хэша. При сканировании контейнера хэша во время запросов нам необходимо сканировать все страницы переполнения. Таким образом, несбалансированный индекс хэша может быть на самом деле хуже, чем B-дерево с точки зрения количества требуемых доступов к блокам для некоторых данных.</p><p>В результате случаев переполнения мы можем сказать, что хэш-индексы наиболее подходят для уникальных, почти уникальных данных или данных с небольшим количеством строк на хэш-контейнер. Один из возможных способов избежать проблем — исключить из индекса крайне неуникальные значения с помощью частичного индексного условия, но во многих случаях это может не подойти.</p><p>Как и B-деревья, хэш-индексы выполняют простое удаление кортежей индексов. Это отложенная операция обслуживания, которая удаляет кортежи индексов, которые, как известно, можно безопасно удалить (те, у которых бит идентификатора элемента LP_DEAD уже установлен). Если вставка обнаруживает, что на странице нет свободного места, мы пытаемся избежать создания новой страницы переполнения, пытаясь удалить мертвые кортежи индексов. Удаление не может произойти, если страница в это время закреплена. Удаление мертвых указателей индексов также происходит во время VACUUM.</p><p>Если это возможно, VACUUM также попытается втиснуть индексные кортежи на как можно меньшее количество страниц переполнения, минимизируя цепочку переполнения. Если страница переполнения становится пустой, страницы переполнения могут быть повторно использованы в других бакетах, хотя мы никогда не возвращаем их в операционную систему. В настоящее время нет возможности сжать хэш-индекс, кроме как перестроить его с помощью REINDEX. Также нет возможности уменьшить количество бакетов.</p><p>Индексы хэша могут расширять количество страниц контейнеров по мере роста количества индексированных строк. Сопоставление ключа хэша с номером контейнера выбирается таким образом, чтобы индекс мог постепенно расширяться. Когда в индекс добавляется новый контейнер, необходимо будет «разделить» ровно один существующий контейнер, при этом некоторые его кортежи будут перенесены в новый контейнер в соответствии с обновленным сопоставлением ключа с номером контейнера.</p><p>Расширение происходит на переднем плане, что может увеличить время выполнения пользовательских вставок. Таким образом, хэш-индексы могут не подходить для таблиц с быстро растущим числом строк.</p><p>В хэш-индексе есть четыре типа страниц: метастраница (нулевая страница), которая содержит статически выделенную управляющую информацию; основные страницы корзины; страницы переполнения; и страницы битовой карты, которые отслеживают страницы переполнения, которые были освобождены и доступны для повторного использования. Для целей адресации страницы битовой карты рассматриваются как подмножество страниц переполнения.</p><p>Как сканирование индекса, так и вставка кортежей требуют нахождения контейнера, в котором должен находиться данный кортеж. Для этого нам нужны количество контейнеров, верхняя маска и нижняя маска из метастраницы; однако, по соображениям производительности нежелательно блокировать и закреплять метастраницу для каждой такой операции. Вместо этого мы сохраняем кэшированную копию метастраницы в записи relcache каждого бэкэнда. Это даст правильное сопоставление контейнера, пока целевой контейнер не был разделен с момента последнего обновления кэша.</p><p>Первичные страницы контейнера и страницы переполнения выделяются независимо, поскольку любому заданному индексу может потребоваться больше или меньше страниц переполнения относительно его количества контейнеров. Хэш-код использует интересный набор правил адресации для поддержки переменного количества страниц переполнения, при этом не требуется перемещать первичные страницы контейнера после их создания.</p><p>Каждая строка в индексированной таблице представлена ​​одним кортежем индекса в хэш-индексе. Кортежи хэш-индекса хранятся на страницах сегмента, и если они существуют, переполняют страницы. Мы ускоряем поиск, сохраняя записи индекса на любой странице индекса отсортированными по хэш-коду, что позволяет использовать бинарный поиск на странице индекса. Однако следует отметить, что нет *никаких* предположений об относительном порядке хэш-кодов на разных страницах индекса сегмента.</p><p>Алгоритмы разделения корзины для расширения хэш-индекса слишком сложны, чтобы упоминать их здесь, хотя они более подробно описаны в src/backend/access/hash/README. Алгоритм разделения защищен от сбоев и может быть перезапущен, если не будет успешно завершен.</p>

